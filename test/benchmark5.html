<!doctype html>

<html lang="en">
<head>

  <meta charset="utf-8">
</head>

<body>

  <script type="text/javascript">
// Generated by CoffeeScript 1.8.0
var ClassConstraint, Constrained, Context, ForAll, KindFn, QuantifiedVar, TempType, TypeApp, TypeConstr, TypeVariable, Types, accessList, addAllToSet, addConstraints, addToMap, addToSet, all, allMap, any, applyKindFn, arrayToMap, arrayToSet, arrowType, assignCompile, assignMethodTypes, astFromSource, astize, astizeExpression, astizeExpressionWithWrapper, astizeList, atomCompile, atomicType, attachPrintedTypes, binaryFnMapping, binaryMathOpType, binaryOpMapping, bindVariable, blockOfLines, boolType, builtInDefinitions, builtInMacros, builtInTypeNames, cache_, callCompile, callConstructorPattern, callInfer, callInferSingle, callKnownCompile, callSaturatedKnownCompile, callTyping, callUnknownCompile, callUnknownTranslate, call_, charCompile, charType, checkTypes, cloneMap, cloneSet, collapse, collectArgs, collectRequiresFor, collectRequiresWithAcc, colorize, combinePatterns, comparatorOpType, compileAstToJs, compileCtxAstToJs, compileDeferred, compileExpression, compileToJs, compileTopLevel, compileTopLevelAndExpression, compileTopLevelSource, compileVariableAssignment, compiledModules, concat, concatConcatMaps, concatMap, concatMaps, concatSets, cond_, conditional, constPattern, constantLabeling, constraintsFromInstance, constraintsFromSuperClasses, constructCond, controls, crawl, createIndent, debug, declareMethods, deferConstraints, deferredExpression, definitionList, definitionPairCompile, delims, desiplifyType, desiplifyTypeAndArity, dictForConstraint, dictsForConstraint, doIntersect, emptySubstitution, entail, expandBuiltings, exportList, expressionCompile, expressionsCompile, filter, filterAst, filterMap, filterSet, findClassType, findDataType, findDeclarables, findFree, findFreeInList, findSubClassParam, findSuperClassChain, findSuperClassInstances, first, flattenType, fn_, freshInstance, freshName, hashmapCompile, hashmapType, hashsetType, highlightType, hoistWheres, i, id, iife, immutable, inSet, inSub, indentLines, injectContext, injectedContext, instanceDictFor, instancePrefix, intersectRight, invertedBinaryFnMapping, invertedBinaryOpMapping, irCall, irCallTranslate, irDefinition, irDefinitionTranslate, irFunction, irFunctionTranslate, irJsCompatible, irJsCompatibleTranslate, irList, irListTranslate, irMap, irMapTranslate, irMethod, irMethodTranslate, irSet, irSetTranslate, isAlreadyParametrized, isAtom, isCall, isCapital, isComment, isConstructor, isCustomCollectionType, isEmptyForm, isForm, isLabel, isMapEmpty, isName, isNormalizedConstraint, isNormalizedConstraintArgument, isRecord, isSeq, isSetEmpty, isSimpleTranslated, isSplat, isSubset, isTranslated, isTuple, isTypeAnnotation, isWellformed, join, joinSubs, jsAccess, jsAccessTranslate, jsArray, jsArrayTranslate, jsAssign, jsAssignStatement, jsAssignStatementTranslate, jsAssignTranslate, jsBinary, jsBinaryMulti, jsBinaryMultiTranslate, jsBinaryTranslate, jsCall, jsCallTranslate, jsConditional, jsConditionalTranslate, jsExprList, jsExprListTranslate, jsFunction, jsFunctionTranslate, jsMalformed, jsMalformedTranslate, jsMethod, jsNew, jsNewTranslate, jsNoop, jsNoopTranslate, jsReturn, jsReturnTranslate, jsTernary, jsTernaryTranslate, jsUnary, jsUnaryTranslate, jsVarDeclaration, jsVarDeclarationTranslate, jsVarDeclarations, jsVarDeclarationsTranslate, keysOfMap, kind, kindFn, kindFnOfArgs, kindsEq, labelComments, labelMapping, labelOf, labelOperator, labelRequires, labeledToMap, leftDelims, library, listOf, listOfLines, listToPairsWith, listType, literalPattern, logError, lookupInMap, lookupJs, macroCompile, macros, malformed, map, mapCompile, mapMap, mapSet, mapSub, mapSyntax, mapToArray, mapToArrayVia, mapToSubstitution, mapTyping, mapTypingBare, matchBranchTranslate, matchType, mergeSubs, moduleGraph, mostGeneralUnifier, ms, ms_Map, ms_Set, ms_class, ms_data, ms_eq, ms_fn, ms_format, ms_instance, ms_macro, ms_match, ms_record, ms_type, nameCompile, nameTranslate, nestedAddToMap, nestedLookupInMap, newMap, newMapKeysVals, newMapWith, newSet, newSetWith, newSubstitution, noWhitespace, normalizeConstraint, normalizeConstraints, numType, numericalCompile, objectToMap, operatorCompile, pairs, pairsLeft, pairsRight, paramTupleIn, parentize, parseUnConstrainedType, partition, patternCompile, prefixWithInstanceName, printIr, printType, quantify, quantifyAll, quantifyUnbound, reduceConstraints, reduceSet, regexCompile, removeAllFromSet, removeFromMap, removeFromSet, replaceInMap, replaceOrAddToMap, replicate, requireName, reservedInJs, resolveDeferredTypes, retrieve, reverse, rightDelims, runTests, safePrintType, seqCompile, seqOrMapCompile, setToArray, simpleMacro, simplifyConstraints, specialCharacters, splatToName, star, stringType, string_, subIntersection, subLimit, subStart, subUnion, substituionFail, substitute, substituteList, subtractContexts, subtractMaps, subtractSets, syntaxNameAs, syntaxNewName, syntaxType, syntaxedExpHtml, syntaxedType, tagFreeLabels, teas, termCompile, termsCompile, test, testNamed, tests, theme, toConstrained, toForAll, toHtml, toJsString, toMatchTypes, token_, tokenize, topLevel, topLevelAndExpression, topLevelExpression, translateDict, translateIr, translateStatementsToJs, translateToJs, tupleCompile, tupleOfTypes, tupleType, tuple_, tuplize, typeCompile, typeConstant, typeConstrainedCompile, typeConstraintCompile, typeConstraintsCompile, typeConstructorCompile, typeEnumaration, typeEq, typeFn, typeNameCompile, typeNamesOfNormalized, typeTupleCompile, typesCompile, unaryFnMapping, uniformCollectionCompile, uniformCollectionItemsCompile, unify, unifyFail, unzip, validIdentifier, values, varList, varNames, visitExpressions, walk, walkIr, zip, zipWith, __, _arguments, _assigns, _cache, _constraints, _fn, _fst, _i, _is, _labelName, _labeled, _len, _names, _notEmpty, _operator, _precs, _ref, _snd, _stringValue, _symbol, _terms, _type,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  __slice = [].slice;

tokenize = function(input, initPos) {
  var currentPos, end, match, start, symbol, _results;
  if (initPos == null) {
    initPos = 0;
  }
  currentPos = initPos;
  _results = [];
  while (input.length > 0) {
    match = input.match(RegExp("^(\\x20|\\n|[" + controls + "]|/([^\\s]|\\\\/)([^/]|\\\\/)*?/|\"(?:[^\"\\\\]|\\\\.)*\"|\\\\[^\\x20" + controls + "]+|[^" + controls + "\"'\\s]+)"));
    if (!match) {
      throw new Error("Could not recognize a token starting with `" + input.slice(0, 11) + "`");
    }
    symbol = match[0];
    input = input.slice(symbol.length);
    start = currentPos;
    currentPos += symbol.length;
    end = currentPos;
    _results.push(constantLabeling({
      symbol: symbol,
      start: start,
      end: end
    }));
  }
  return _results;
};

controls = '\\(\\)\\[\\]\\{\\}';

astize = function(tokens, initialDepth) {
  var ast, closed, current, form, indentAccumulator, stack, token, tree, _i, _len, _ref, _ref1;
  if (initialDepth == null) {
    initialDepth = 0;
  }
  tree = [];
  current = [];
  stack = [[]];
  indentAccumulator = [];
  for (_i = 0, _len = tokens.length; _i < _len; _i++) {
    token = tokens[_i];
    if (token.symbol === ' ' && (indentAccumulator != null ? indentAccumulator.length : void 0) < 2 * (initialDepth + stack.length - 1)) {
      indentAccumulator.push(token);
    } else {
      if ((indentAccumulator != null ? indentAccumulator.length : void 0) > 0) {
        stack[stack.length - 1].push(createIndent(indentAccumulator));
      }
      indentAccumulator = void 0;
      if (token.symbol === '\n') {
        indentAccumulator = [];
      }
      if (_ref = token.symbol, __indexOf.call(leftDelims, _ref) >= 0) {
        form = [token];
        form.start = token.start;
        stack.push(form);
      } else if (_ref1 = token.symbol, __indexOf.call(rightDelims, _ref1) >= 0) {
        closed = stack.pop();
        if (!stack[stack.length - 1]) {
          throw new Error("Missing opening delimeter matching " + token.symbol);
        }
        if (token.symbol !== delims[closed[0].symbol]) {
          throw new Error("Wrong closing delimiter " + token.symbol + " for opening delimiter " + closed[0].symbol);
        }
        closed.push(token);
        closed.end = token.end;
        stack[stack.length - 1].push(closed);
      } else {
        stack[stack.length - 1].push(token);
      }
    }
  }
  ast = stack[0][0];
  if (!ast) {
    throw new Error("Missing closing delimeter matching " + stack[stack.length - 1][0].symbol);
  } else {
    return ast;
  }
};

leftDelims = ['(', '[', '{'];

rightDelims = [')', ']', '}'];

delims = {
  '(': ')',
  '[': ']',
  '{': '}'
};

createIndent = function(accumulator) {
  return {
    symbol: (new Array(accumulator.length + 1)).join(' '),
    start: accumulator[0].start,
    end: accumulator[accumulator.length - 1].end,
    label: 'indent'
  };
};

constantLabeling = function(atom) {
  var symbol;
  symbol = atom.symbol;
  return labelMapping(atom, ['numerical', /^~?\d+/.test(symbol)], ['label', isLabel(atom)], ['string', /^"/.test(symbol)], ['char', /^\\/.test(symbol)], ['regex', /^\/[^\s\/]/.test(symbol)], ['const', /^[A-Z][^\s\.]*$/.test(symbol)], ['paren', symbol === '(' || symbol === ')'], ['bracket', symbol === '[' || symbol === ']'], ['brace', symbol === '{' || symbol === '}'], ['whitespace', /^\s+$/.test(symbol)]);
};

noWhitespace = function(tokens) {
  return tokens.filter(function(token) {
    var _ref;
    return (_ref = token.label) !== 'whitespace' && _ref !== 'indent';
  });
};

labelMapping = function() {
  var cond, label, rules, word, _i, _len, _ref;
  word = arguments[0], rules = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
  for (_i = 0, _len = rules.length; _i < _len; _i++) {
    _ref = rules[_i], label = _ref[0], cond = _ref[1];
    if (!(cond)) {
      continue;
    }
    word.label = label;
    return word;
  }
  return word;
};

labelOperator = function(expression) {
  var close, open, _, _i;
  if (isForm(expression)) {
    open = expression[0], _ = 3 <= expression.length ? __slice.call(expression, 1, _i = expression.length - 1) : (_i = 1, []), close = expression[_i++];
    return open.label = close.label = 'operator';
  } else {
    return expression.label = 'operator';
  }
};

crawl = function(ast, cb, parent) {
  var node, _i, _len, _results;
  if (Array.isArray(ast)) {
    _results = [];
    for (_i = 0, _len = ast.length; _i < _len; _i++) {
      node = ast[_i];
      _results.push(crawl(node, cb, ast));
    }
    return _results;
  } else {
    return cb(ast, ast.symbol, parent);
  }
};

visitExpressions = function(expression, cb) {
  var term, _i, _len, _ref, _results;
  cb(expression);
  if (isForm(expression)) {
    _ref = _terms(expression);
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      term = _ref[_i];
      _results.push(visitExpressions(term, cb));
    }
    return _results;
  }
};

teas = function(fn, string) {
  var ast, compiled, ctx;
  ast = astize(tokenize(string));
  compiled = fn((ctx = new Context), ast);
  return {
    syntax: collapse(toHtml(ast)),
    types: values(mapMap(__(highlightType, _type), subtractMaps(ctx._scope(), builtInDefinitions()))),
    translation: '\n' + compiled
  };
};

mapCompile = function(fn, string) {
  return fn(new Context, astize(tokenize(string)));
};

mapTyping = function(fn, string) {
  var ast, ctx, expressions;
  ast = astize(tokenize(string));
  fn((ctx = new Context), ast);
  expressions = [];
  visitExpressions(ast, function(expression) {
    if (expression.tea) {
      return expressions.push("" + (collapse(toHtml(expression))) + " :: " + (highlightType(expression.tea)));
    }
  });
  return {
    types: values(mapMap(__(highlightType, _type), subtractMaps(ctx._scope(), builtInDefinitions()))),
    subs: mapSub(highlightType, ctx.substitution),
    ast: expressions,
    deferred: ctx.deferredBindings()
  };
};

mapTypingBare = function(fn, string) {
  var ast, ctx, expressions;
  ast = astize(tokenize(string));
  fn((ctx = new Context), ast);
  expressions = [];
  visitExpressions(ast, function(expression) {
    if (expression.tea) {
      return expressions.push([collapse(toHtml(expression)), expression.tea]);
    }
  });
  return {
    types: values(mapMap(_type, subtractMaps(ctx._scope(), builtInDefinitions()))),
    subs: ctx.substitution,
    ast: expressions,
    deferred: ctx.deferredBindings()
  };
};

highlightType = function(type) {
  var typeAst;
  typeAst = astize(tokenize(printType(type)));
  syntaxType(typeAst);
  return collapse(toHtml(typeAst));
};

_type = function(declaration) {
  return declaration.type;
};

mapSyntax = function(fn, string) {
  var ast;
  ast = astize(tokenize(string));
  fn(new Context, ast);
  return collapse(toHtml(ast));
};

Context = (function() {
  function Context() {
    var topScope;
    this._macros = builtInMacros();
    this.expand = {};
    this.definitions = [];
    this._isOperator = [];
    this.variableIndex = 0;
    this.typeVariabeIndex = 0;
    this.nameIndex = 1;
    this.substitution = emptySubstitution();
    this.statement = [];
    this.cacheScopes = [[]];
    this._assignTos = [];
    topScope = this._augmentScope(builtInDefinitions());
    topScope.typeNames = builtInTypeNames();
    topScope.topLevel = true;
    this.scopes = [topScope];
    this.classParams = newMap();
  }

  Context.prototype.macros = function() {
    return this._macros;
  };

  Context.prototype.addMacro = function(name, macro) {
    return this._macros[name] = macro;
  };

  Context.prototype.definePattern = function(pattern) {
    if (this.isDefining()) {
      throw new Error("already defining, forgot to leaveDefinition?");
    }
    return this._scope().definition = {
      name: pattern != null ? pattern.symbol : void 0,
      pattern: pattern,
      inside: 0,
      late: false,
      deferredBindings: [],
      definedNames: [],
      deferrable: true,
      _defer: void 0
    };
  };

  Context.prototype.defineNonDeferrablePattern = function(pattern) {
    var definition;
    definition = this.definePattern(pattern);
    return definition.deferrable = false;
  };

  Context.prototype.leaveDefinition = function() {
    return this._scope().definition = void 0;
  };

  Context.prototype.downInsideDefinition = function() {
    var _ref;
    return (_ref = this._definition()) != null ? _ref.inside++ : void 0;
  };

  Context.prototype.upInsideDefinition = function() {
    var _ref;
    return (_ref = this._definition()) != null ? _ref.inside-- : void 0;
  };

  Context.prototype.definitionName = function() {
    return this._definition().name;
  };

  Context.prototype.definitionPattern = function() {
    return this._definition().pattern;
  };

  Context.prototype._currentDefinition = function() {
    return this._scope().definition;
  };

  Context.prototype._definition = function() {
    return this._definitionAtScope(this.scopes.length - 1);
  };

  Context.prototype._definitionAtScope = function(i) {
    return this.scopes[i].definition || i > 0 && (this._definitionAtScope(i - 1)) || void 0;
  };

  Context.prototype._deferrableDefinition = function() {
    return this._deferrableDefinitionAtScope(this.scopes.length - 1);
  };

  Context.prototype._deferrableDefinitionAtScope = function(i) {
    var def;
    return (def = this.scopes[i].definition) && def.deferrable && def || i > 0 && (this._deferrableDefinitionAtScope(i - 1)) || void 0;
  };

  Context.prototype.isDefining = function() {
    return !!this._scope().definition;
  };

  Context.prototype.isAtDefinition = function() {
    var definition;
    return (definition = this._currentDefinition()) && definition.inside === 0;
  };

  Context.prototype.isAtSimpleDefinition = function() {
    return this.isAtDefinition() && this.definitionName();
  };

  Context.prototype.isAtDeferrableDefinition = function() {
    return this.isAtDefinition() && this._currentDefinition().deferrable;
  };

  Context.prototype.isOperator = function() {
    return this._isOperator[this._isOperator.length - 1];
  };

  Context.prototype.setIsOperator = function(isOperator) {
    return this._isOperator.push(isOperator);
  };

  Context.prototype.resetIsOperator = function() {
    return this._isOperator.pop();
  };

  Context.prototype.setAssignTo = function(compiled) {
    return this._assignTos.push({
      value: compiled
    });
  };

  Context.prototype.assignTo = function() {
    var _ref;
    return (_ref = this._assignTos[this._assignTos.length - 1]) != null ? _ref.value : void 0;
  };

  Context.prototype.cacheAssignTo = function() {
    var assignTo, cache, cacheName;
    assignTo = this._assignTos[this._assignTos.length - 1];
    if ((assignTo != null ? assignTo.value : void 0) && !assignTo.cache) {
      cacheName = this.newJsVariable();
      cache = [cacheName, this.assignTo()];
      return this._assignTos[this._assignTos.length - 1] = {
        value: cacheName,
        cache: cache
      };
    }
  };

  Context.prototype.resetAssignTo = function() {
    var cache;
    if (cache = this._assignTos.pop().cache) {
      return [compileVariableAssignment(cache)];
    } else {
      return [];
    }
  };

  Context.prototype._scope = function() {
    return this.scopes[this.scopes.length - 1];
  };

  Context.prototype._parentScope = function() {
    return this.scopes[this.scopes.length - 2];
  };

  Context.prototype.newScope = function() {
    return this.scopes.push(this._augmentScope(newMap()));
  };

  Context.prototype._augmentScope = function(scope) {
    scope.deferred = [];
    scope.deferredBindings = [];
    scope.boundTypeVariables = newSet();
    scope.classes = newMap();
    scope.typeNames = newMap();
    scope.typeAliases = newMap();
    return scope;
  };

  Context.prototype.newLateScope = function() {
    var _ref;
    this.newScope();
    return (_ref = this._deferrableDefinition()) != null ? _ref.late = true : void 0;
  };

  Context.prototype.closeScope = function() {
    return this.scopes.pop();
  };

  Context.prototype.isInsideLateScope = function() {
    var _ref;
    return (_ref = this._deferrableDefinition()) != null ? _ref.late : void 0;
  };

  Context.prototype.isInTopScope = function() {
    return this._scope().topLevel;
  };

  Context.prototype.addTypeName = function(dataType) {
    var kind, name, _ref;
    if (dataType instanceof TypeApp) {
      _ref = dataType.op, name = _ref.name, kind = _ref.kind;
    } else {
      name = dataType.name, kind = dataType.kind;
    }
    return addToMap(this._scope().typeNames, name, kind);
  };

  Context.prototype.kindOfTypeName = function(name) {
    var kind, scope, _i, _len, _ref;
    _ref = reverse(this.scopes);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      scope = _ref[_i];
      if (kind = lookupInMap(scope.typeNames, name)) {
        return kind;
      }
    }
  };

  Context.prototype.addTypeAlias = function(name, type) {
    return addToMap(this._scope().typeAliases, name, type);
  };

  Context.prototype.resolveTypeAliases = function(name) {
    var alias;
    if (alias = lookupInMap(this._scope().typeAliases, name)) {
      return alias;
    } else {
      return name;
    }
  };

  Context.prototype.bindTypeVariables = function(vars) {
    return addAllToSet(this._scope().boundTypeVariables, vars);
  };

  Context.prototype.allBoundTypeVariables = function() {
    var scope;
    return concatSets.apply(null, (function() {
      var _i, _len, _ref, _results;
      _ref = this.scopes;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        scope = _ref[_i];
        _results.push(scope.boundTypeVariables);
      }
      return _results;
    }).call(this));
  };

  Context.prototype.isClassDefined = function(name) {
    return !!this.classNamed(name);
  };

  Context.prototype.addClass = function(name, classConstraint, superClasses, declarations) {
    return addToMap(this._scope().classes, name, {
      supers: superClasses,
      constraint: classConstraint,
      instances: [],
      declarations: declarations
    });
  };

  Context.prototype.classNamed = function(name) {
    var classDeclaration, scope, _i, _len, _ref;
    _ref = reverse(this.scopes);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      scope = _ref[_i];
      if (classDeclaration = lookupInMap(scope.classes, name)) {
        return classDeclaration;
      }
    }
  };

  Context.prototype.addInstance = function(name, type) {
    return (this.classNamed(type.type.className)).instances.push({
      name: name,
      type: type
    });
  };

  Context.prototype.isMethod = function(name, type) {
    var className;
    return any((function() {
      var _i, _len, _ref, _results;
      _ref = type.constraints;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        className = _ref[_i].className;
        _results.push(lookupInMap((this.classNamed(className)).declarations, name));
      }
      return _results;
    }).call(this));
  };

  Context.prototype.isDeclared = function(name) {
    return !!(this._declaration(name));
  };

  Context.prototype.isTyped = function(name) {
    return !!(this._declaration(name)).type;
  };

  Context.prototype._declaration = function(name) {
    return this._declarationInScope(this.scopes.length - 1, name);
  };

  Context.prototype._declarationInScope = function(i, name) {
    return (lookupInMap(this.scopes[i], name)) || i > 0 && (this._declarationInScope(i - 1, name)) || void 0;
  };

  Context.prototype.isCurrentlyDeclared = function(name) {
    return !!(lookupInMap(this._scope(), name));
  };

  Context.prototype.assignType = function(name, type) {
    var declaration;
    if (declaration = lookupInMap(this._scope(), name)) {
      if (declaration.type) {
        throw new Error("assignType: " + name + " already has a type");
      }
      return declaration.type = type;
    } else {
      throw new Error("assignType: " + name + " is not declared");
    }
  };

  Context.prototype.currentDeclarations = function() {
    return cloneMap(this._scope());
  };

  Context.prototype.addToDeferredNames = function(binding) {
    return this._definition().deferredBindings.push(binding);
  };

  Context.prototype.addToDeferred = function(binding) {
    return this._scope().deferredBindings.push(binding);
  };

  Context.prototype.addToDefinedNames = function(binding) {
    var _ref, _ref1;
    return (_ref = this._currentDefinition()) != null ? (_ref1 = _ref.definedNames) != null ? _ref1.push(binding) : void 0 : void 0;
  };

  Context.prototype.definedNames = function() {
    var _ref, _ref1;
    return (_ref = (_ref1 = this._currentDefinition()) != null ? _ref1.definedNames : void 0) != null ? _ref : [];
  };

  Context.prototype.deferredNames = function() {
    return this._definition().deferredBindings;
  };

  Context.prototype.deferredBindings = function() {
    return this._scope().deferredBindings;
  };

  Context.prototype.declareArity = function(name, arity) {
    return this.declare(name, {
      arity: arity
    });
  };

  Context.prototype.declare = function(name, declaration) {
    if (declaration == null) {
      declaration = {};
    }
    if (lookupInMap(this._scope(), name)) {
      return false;
    } else {
      if (declaration.id == null) {
        declaration.id = this.freshId();
      }
      addToMap(this._scope(), name, declaration);
      return true;
    }
  };

  Context.prototype.freshId = function() {
    return this.nameIndex++;
  };

  Context.prototype.declareTypes = function(names, types) {
    var i, name, _i, _len, _results;
    _results = [];
    for (i = _i = 0, _len = names.length; _i < _len; i = ++_i) {
      name = names[i];
      _results.push(this.declare(name, {
        type: types[i]
      }));
    }
    return _results;
  };

  Context.prototype.type = function(name) {
    var _ref;
    return (_ref = this._declaration(name)) != null ? _ref.type : void 0;
  };

  Context.prototype.declarationId = function(name) {
    var _ref;
    return (_ref = this._declaration(name)) != null ? _ref.id : void 0;
  };

  Context.prototype.arity = function(name) {
    var _ref;
    return (_ref = this._declaration(name)) != null ? _ref.arity : void 0;
  };

  Context.prototype.freshTypeVariable = function(kind) {
    var name;
    if (!kind) {
      throw new Error("Provide kind in freshTypeVariable");
    }
    name = freshName(this.typeVariabeIndex++);
    if (inSet(this.allBoundTypeVariables(), name)) {
      return this.freshTypeVariable(kind);
    } else {
      return new TypeVariable(name, kind);
    }
  };

  Context.prototype.extendSubstitution = function(substitution) {
    return this.substitution = joinSubs(substitution, this.substitution);
  };

  Context.prototype.newJsVariable = function() {
    return "i" + (this.variableIndex++);
  };

  Context.prototype.doDefer = function(expression, dependencyName) {
    return this._setDeferIn(this._deferrableDefinition(), expression, dependencyName);
  };

  Context.prototype._setDeferIn = function(definition, expression, dependencyName) {
    return definition._defer = (this._deferReasonOf(definition)) || [expression, dependencyName];
  };

  Context.prototype.deferReason = function() {
    return this._deferReasonOf(this._deferrableDefinition());
  };

  Context.prototype.shouldDefer = function() {
    return !!(this._deferReasonOf(this._deferrableDefinition()));
  };

  Context.prototype._deferReasonOf = function(definition) {
    return definition != null ? definition._defer : void 0;
  };

  Context.prototype.addDeferredDefinition = function(_arg) {
    var dependencyName, expression, lhs, rhs;
    expression = _arg[0], dependencyName = _arg[1], lhs = _arg[2], rhs = _arg[3];
    return this._scope().deferred.push([expression, dependencyName, lhs, rhs]);
  };

  Context.prototype.deferred = function() {
    return this._scope().deferred;
  };

  Context.prototype.addClassParams = function(params) {
    return this.classParams = concatMaps(this.classParams, params);
  };

  Context.prototype.classParamNameFor = function(constraint) {
    var typeMap;
    typeMap = this.classParamsForType(constraint);
    if (typeMap) {
      return lookupInMap(typeMap, constraint.className);
    }
  };

  Context.prototype.classParamsForType = function(constraint) {
    return nestedLookupInMap(this.classParams, typeNamesOfNormalized(constraint));
  };

  return Context;

})();

expressionCompile = function(ctx, expression) {
  var compileFn;
  if (!(ctx instanceof Context && expression)) {
    throw new Error("invalid expressionCompile args");
  }
  compileFn = isAtom(expression) ? atomCompile : isTuple(expression) ? tupleCompile : isSeq(expression) ? seqOrMapCompile : isCall(expression) ? callCompile : void 0;
  if (!compileFn) {
    return malformed(expression, 'not a valid expression');
  } else {
    return compileFn(ctx, expression);
  }
};

callCompile = function(ctx, call) {
  var expandedOp, operator, operatorName;
  operator = _operator(call);
  operatorName = _symbol(operator);
  if (isName(operator)) {
    return (operatorName in ctx.macros() && !ctx.arity(operatorName) ? macroCompile : (ctx.isDeclared(operatorName)) && !ctx.arity(operatorName) ? callUnknownCompile : callKnownCompile)(ctx, call);
  } else {
    expandedOp = termCompile(ctx, operator);
    if (isTranslated(expandedOp)) {
      return callUnknownTranslate(ctx, expandedOp, call);
    } else {
      return expressionCompile(ctx, replicate(call, call_(join([expandedOp], _arguments(call)))));
    }
  }
};

macroCompile = function(ctx, call) {
  var expanded, op;
  op = _operator(call);
  op.label = 'keyword';
  expanded = ctx.macros()[op.symbol](ctx, call);
  if (isTranslated(expanded)) {
    return expanded;
  } else {
    return expressionCompile(ctx, expanded);
  }
};

isTranslated = function(result) {
  return (isSimpleTranslated(result)) || (Array.isArray(result)) && (isSimpleTranslated(result[0]));
};

isSimpleTranslated = function(result) {
  return result.js || result.ir;
};

callUnknownCompile = function(ctx, call) {
  return callUnknownTranslate(ctx, operatorCompile(ctx, call), call);
};

callKnownCompile = function(ctx, call) {
  var args, argsInOrder, compiled, extraArgs, extraParamNames, extraParams, labeledArgs, lambda, nonLabeledArgs, operator, param, paramNames, positionalArgs, positionalParams, sortedCall;
  operator = _operator(call);
  args = _labeled(_arguments(call));
  labeledArgs = labeledToMap(args);
  if (tagFreeLabels(args)) {
    return malformed(call, 'labels without values inside call');
  }
  paramNames = ctx.arity(operator.symbol);
  if (!paramNames) {
    ctx.doDefer(operator, operator.symbol);
    return deferredExpression();
  }
  positionalParams = filter((function(param) {
    return !(lookupInMap(labeledArgs, param));
  }), paramNames);
  nonLabeledArgs = map(_snd, filter((function(_arg) {
    var label, value;
    label = _arg[0], value = _arg[1];
    return !label;
  }), args));
  if (nonLabeledArgs.length > positionalParams.length) {
    return malformed(call, 'Too many arguments');
  } else {
    extraParamNames = positionalParams.slice(nonLabeledArgs.length);
    extraParams = map(token_, extraParamNames);
    positionalArgs = map(id, nonLabeledArgs);
    extraArgs = map(id, extraParams);
    argsInOrder = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = paramNames.length; _i < _len; _i++) {
        param = paramNames[_i];
        _results.push((lookupInMap(labeledArgs, param)) || positionalArgs.shift() || extraArgs.shift());
      }
      return _results;
    })();
    sortedCall = call_(operator, argsInOrder);
    if (ctx.assignTo()) {
      if (isCapital(operator)) {
        if (args.length < paramNames.length && nonLabeledArgs.length > 0) {
          return malformed(call, "curried constructor pattern");
        } else {
          compiled = callConstructorPattern(ctx, sortedCall, extraParamNames);
          retrieve(call, sortedCall);
          return compiled;
        }
      } else {
        return malformed(call, "function patterns not supported");
      }
    } else {
      if (nonLabeledArgs.length < positionalParams.length) {
        lambda = fn_(extraParams, sortedCall);
        compiled = macroCompile(ctx, lambda);
        retrieve(call, lambda);
        return compiled;
      } else {
        compiled = operator.symbol in ctx.macros() ? macroCompile(ctx, sortedCall) : callSaturatedKnownCompile(ctx, sortedCall);
        retrieve(call, sortedCall);
        return compiled;
      }
    }
  }
};

callConstructorPattern = function(ctx, call, extraParamNames) {
  var arg, args, compiledArgs, elemCompiled, i, isExtra, operator, paramNames, precsForData, _i, _len;
  operator = _operator(call);
  args = _arguments(call);
  isExtra = function(arg) {
    var _ref;
    return (isAtom(arg)) && (_ref = _symbol(arg), __indexOf.call(extraParamNames, _ref) >= 0);
  };
  paramNames = ctx.arity(operator.symbol);
  if (args.length - extraParamNames.length > 1) {
    ctx.cacheAssignTo();
  }
  compiledArgs = (function() {
    var _i, _len, _results;
    _results = [];
    for (i = _i = 0, _len = args.length; _i < _len; i = ++_i) {
      arg = args[i];
      if (!(!isExtra(arg))) {
        continue;
      }
      ctx.setAssignTo(jsAccess(ctx.assignTo(), paramNames[i]));
      elemCompiled = expressionCompile(ctx, arg);
      ctx.resetAssignTo();
      _results.push(elemCompiled);
    }
    return _results;
  })();
  precsForData = operatorCompile(ctx, call);
  for (_i = 0, _len = args.length; _i < _len; _i++) {
    arg = args[_i];
    if (isExtra(arg)) {
      arg.tea = toConstrained(ctx.freshTypeVariable(star));
    }
  }
  callTyping(ctx, call);
  return combinePatterns(join([precsForData], compiledArgs));
};

callSaturatedKnownCompile = function(ctx, call) {
  var args, compiledArgs, compiledOperator, operator;
  operator = _operator(call);
  args = _arguments(call);
  compiledOperator = operatorCompile(ctx, call);
  compiledArgs = termsCompile(ctx, args);
  callTyping(ctx, call);
  return assignCompile(ctx, call, irCall(operator.tea, compiledOperator, compiledArgs));
};

labeledToMap = function(pairs) {
  var labelNaming;
  labelNaming = function(_arg) {
    var label, value;
    label = _arg[0], value = _arg[1];
    return [_labelName(label), value];
  };
  return newMapKeysVals.apply(null, unzip(map(labelNaming, filter(all, pairs))));
};

tagFreeLabels = function(pairs) {
  var freeLabels;
  freeLabels = filter((function(_arg) {
    var label, value;
    label = _arg[0], value = _arg[1];
    return !value;
  }), pairs);
  freeLabels.map(function(label) {
    return label.label = 'malformed';
  });
  return freeLabels.length > 0;
};

operatorCompile = function(ctx, call) {
  var compiledOperator;
  ctx.setIsOperator(true);
  ctx.downInsideDefinition();
  compiledOperator = atomCompile(ctx, _operator(call));
  ctx.upInsideDefinition();
  ctx.resetIsOperator();
  return compiledOperator;
};

callUnknownTranslate = function(ctx, translatedOperator, call) {
  var argList, args;
  args = _arguments(call);
  argList = ctx.shouldDefer() ? deferredExpression() : termsCompile(ctx, args);
  callTyping(ctx, call);
  return assignCompile(ctx, call, jsCall("_" + args.length, join([translatedOperator], argList)));
};

callTyping = function(ctx, call) {
  if (ctx.shouldDefer()) {
    return;
  }
  return call.tea = callInfer(ctx, _terms(call));
};

callInfer = function(ctx, terms) {
  var arg, lastArg, op, subTerms, _i;
  if (terms.length > 2) {
    subTerms = 2 <= terms.length ? __slice.call(terms, 0, _i = terms.length - 1) : (_i = 0, []), lastArg = terms[_i++];
    return callInferSingle(ctx, callInfer(ctx, subTerms), lastArg.tea);
  } else {
    op = terms[0], arg = terms[1];
    return callInferSingle(ctx, op.tea, arg.tea);
  }
};

callInferSingle = function(ctx, operatorTea, argTea) {
  var returnType;
  returnType = ctx.freshTypeVariable(star);
  unify(ctx, operatorTea.type, typeFn(argTea.type, returnType));
  return new Constrained(join(operatorTea.constraints, argTea.constraints), returnType);
};

termsCompile = function(ctx, list) {
  var term, _i, _len, _results;
  _results = [];
  for (_i = 0, _len = list.length; _i < _len; _i++) {
    term = list[_i];
    _results.push(termCompile(ctx, term));
  }
  return _results;
};

termCompile = function(ctx, term) {
  var compiled;
  ctx.downInsideDefinition();
  ctx.setIsOperator(false);
  compiled = expressionCompile(ctx, term);
  ctx.resetIsOperator();
  ctx.upInsideDefinition();
  return compiled;
};

expressionsCompile = function(ctx, list) {
  var expression, _i, _len, _results;
  _results = [];
  for (_i = 0, _len = list.length; _i < _len; _i++) {
    expression = list[_i];
    _results.push(expressionCompile(ctx, expression));
  }
  return _results;
};

tupleCompile = function(ctx, form) {
  var arity, compiledElems, elem, elemCompiled, elems, i, tea;
  elems = _terms(form);
  arity = elems.length;
  if (arity > 1) {
    ctx.cacheAssignTo();
  }
  compiledElems = (function() {
    var _i, _len, _results;
    if (ctx.assignTo()) {
      _results = [];
      for (i = _i = 0, _len = elems.length; _i < _len; i = ++_i) {
        elem = elems[i];
        ctx.setAssignTo(jsAccess(ctx.assignTo(), "" + i));
        elemCompiled = expressionCompile(ctx, elem);
        ctx.resetAssignTo();
        _results.push(elemCompiled);
      }
      return _results;
    } else {
      return termsCompile(ctx, elems);
    }
  })();
  form.tea = tupleOfTypes((function() {
    var _i, _len, _results;
    _results = [];
    for (_i = 0, _len = elems.length; _i < _len; _i++) {
      tea = elems[_i].tea;
      _results.push(tea);
    }
    return _results;
  })());
  if (ctx.assignTo()) {
    return combinePatterns(compiledElems);
  } else {
    labelOperator(form);
    return assignCompile(ctx, form, jsArray(compiledElems));
  }
};

seqOrMapCompile = function(ctx, form) {
  var elems;
  elems = _terms(form);
  return ((_notEmpty(elems)) && isLabel(elems[0]) ? hashmapCompile : seqCompile)(ctx, form);
};

seqCompile = function(ctx, form) {
  var compiledArgs, compiledItems, cond, elem, elemType, elems, hasSplat, i, lhs, lhsCompiled, requiredElems, rhs, sequence, size, tea, _i, _j, _len, _len1;
  elems = _terms(form);
  size = elems.length;
  if (size > 1) {
    ctx.cacheAssignTo();
  }
  if (sequence = ctx.assignTo()) {
    hasSplat = false;
    requiredElems = 0;
    for (_i = 0, _len = elems.length; _i < _len; _i++) {
      elem = elems[_i];
      if (isSplat(elem)) {
        hasSplat = true;
      } else {
        requiredElems++;
      }
    }
    if (hasSplat && requiredElems === 0) {
      return malformed(form, 'Matching with splat requires at least one element name');
    }
    compiledArgs = (function() {
      var _j, _len1, _ref, _results;
      _results = [];
      for (i = _j = 0, _len1 = elems.length; _j < _len1; i = ++_j) {
        elem = elems[i];
        _ref = isSplat(elem) ? (elem.label = 'name', [splatToName(elem), jsCall("seq_splat", [i, elems.length - i - 1, sequence])]) : [elem, jsCall("seq_at", [i, sequence])], lhs = _ref[0], rhs = _ref[1];
        ctx.setAssignTo(rhs);
        lhsCompiled = expressionCompile(ctx, lhs);
        retrieve(elem, lhs);
        ctx.resetAssignTo();
        _results.push(lhsCompiled);
      }
      return _results;
    })();
    elemType = ctx.freshTypeVariable(star);
    form.tea = new Constrained(concatMap(_constraints, (function() {
      var _j, _len1, _results;
      _results = [];
      for (_j = 0, _len1 = elems.length; _j < _len1; _j++) {
        tea = elems[_j].tea;
        _results.push(tea);
      }
      return _results;
    })()), new TypeApp(listType, elemType));
    for (_j = 0, _len1 = elems.length; _j < _len1; _j++) {
      elem = elems[_j];
      unify(ctx, elem.tea.type, isSplat(elem) ? form.tea.type : elemType);
    }
    cond = jsBinary((hasSplat ? '>=' : '=='), jsCall("seq_size", [sequence]), requiredElems);
    return combinePatterns(join([
      {
        precs: [cond_(cond)]
      }
    ], compiledArgs));
  } else {
    compiledItems = uniformCollectionCompile(ctx, form, elems, listType);
    return assignCompile(ctx, form, irList(compiledItems));
  }
};

isSplat = function(expression) {
  return (isAtom(expression)) && (_symbol(expression)).slice(0, 2) === '..';
};

splatToName = function(splat) {
  return replicate(splat, token_((_symbol(splat)).slice(2)));
};

hashmapCompile = function(ctx, form) {
  var compiledItems, hashmap, items, keyType, keys, labels, _ref;
  if (hashmap = ctx.assignTo()) {
    throw new Error("matching on hash maps not supported yet");
  } else {
    _ref = unzip(pairs(_terms(form))), labels = _ref[0], items = _ref[1];
    keyType = new TypeApp(hashmapType, stringType);
    compiledItems = uniformCollectionCompile(ctx, form, items, keyType);
    keys = map(__(string_, _labelName), labels);
    return assignCompile(ctx, form, irMap(keys, compiledItems));
  }
};

uniformCollectionCompile = function(ctx, form, items, collectionType, moreConstraints) {
  var compiled, constraints, itemType, _ref;
  if (moreConstraints == null) {
    moreConstraints = [];
  }
  _ref = uniformCollectionItemsCompile(ctx, items), constraints = _ref.constraints, itemType = _ref.itemType, compiled = _ref.compiled;
  if (!isCall(form)) {
    labelOperator(form);
  }
  form.tea = new Constrained(join(moreConstraints, constraints), new TypeApp(collectionType, itemType));
  return compiled;
};

uniformCollectionItemsCompile = function(ctx, items) {
  var compiledItems, item, itemType, tea, _i, _len;
  itemType = ctx.freshTypeVariable(star);
  compiledItems = termsCompile(ctx, items);
  for (_i = 0, _len = items.length; _i < _len; _i++) {
    item = items[_i];
    unify(ctx, itemType, item.tea.type);
  }
  return {
    constraints: concatMap(_constraints, (function() {
      var _j, _len1, _results;
      _results = [];
      for (_j = 0, _len1 = items.length; _j < _len1; _j++) {
        tea = items[_j].tea;
        _results.push(tea);
      }
      return _results;
    })()),
    itemType: itemType,
    compiled: compiledItems
  };
};

typeConstrainedCompile = function(ctx, call) {
  var constraints, type, _ref;
  _ref = _arguments(call), type = _ref[0], constraints = 2 <= _ref.length ? __slice.call(_ref, 1) : [];
  return new Constrained(typeConstraintsCompile(ctx, constraints), typeCompile(ctx, type));
};

typeCompile = function(ctx, expression) {
  var _base;
  if (!expression) {
    throw new Error("invalid typeCompile args");
  }
  return typeof (_base = (isAtom(expression) ? typeNameCompile : isTuple(expression) ? typeTupleCompile : isCall(expression) ? typeConstructorCompile : malformed(expression, 'not a valid type'))) === "function" ? _base(ctx, expression) : void 0;
};

typesCompile = function(ctx, expressions) {
  var e, _i, _len, _results;
  _results = [];
  for (_i = 0, _len = expressions.length; _i < _len; _i++) {
    e = expressions[_i];
    _results.push(typeCompile(ctx, e));
  }
  return _results;
};

typeNameCompile = function(ctx, atom, expectedKind) {
  var expanded, finalKind, kindOfType, type;
  expanded = ctx.resolveTypeAliases(atom.symbol);
  type = expanded === atom.symbol ? (kindOfType = isCapital(atom) ? ctx.kindOfTypeName(atom.symbol) : expectedKind || star, !kindOfType ? malformed(atom, "This type name has not been defined") : void 0, atomicType(atom.symbol, kindOfType)) : expanded;
  finalKind = kind(type);
  if (finalKind instanceof KindFn) {
    labelOperator(atom);
  } else {
    atom.label = 'typename';
  }
  if (expectedKind && (!kindsEq(expectedKind, finalKind))) {
    malformed(atom, "The kind of the type operator doesn't match the supplied number of arguments");
  }
  return type;
};

typeTupleCompile = function(ctx, form) {
  var elemTypes;
  labelOperator(form);
  elemTypes = _terms(form);
  return applyKindFn.apply(null, [tupleType(elemTypes.length)].concat(__slice.call(typesCompile(ctx, elemTypes))));
};

typeConstructorCompile = function(ctx, call) {
  var args, arity, compiledArgs, name, op, operatorType;
  op = _operator(call);
  args = _arguments(call);
  if (isAtom(op)) {
    name = op.symbol;
    compiledArgs = typesCompile(ctx, args);
    if (name === 'Fn') {
      labelOperator(op);
      return typeFn.apply(null, compiledArgs);
    } else {
      arity = args.length;
      operatorType = typeNameCompile(ctx, op, kindFn(arity));
      return applyKindFn.apply(null, [operatorType].concat(__slice.call(compiledArgs)));
    }
  } else {
    return malformed(op, 'Expected a type constructor instead');
  }
};

typeConstraintCompile = function(ctx, expression) {
  var args, op;
  op = _operator(expression);
  args = _arguments(expression);
  if (isCall(expression)) {
    if (isAtom(op)) {
      labelOperator(op);
      return new ClassConstraint(op.symbol, new Types(typesCompile(ctx, args)));
    } else {
      return malformed(expression, 'Class name required in a constraint');
    }
  } else {
    return malformed(expression, 'Class constraint expected');
  }
};

typeConstraintsCompile = function(ctx, expressions) {
  var e;
  return filter((function(t) {
    return t instanceof ClassConstraint;
  }), (function() {
    var _i, _len, _results;
    _results = [];
    for (_i = 0, _len = expressions.length; _i < _len; _i++) {
      e = expressions[_i];
      _results.push(typeConstraintCompile(ctx, e));
    }
    return _results;
  })());
};

assignCompile = function(ctx, expression, translatedExpression) {
  var assigns, precs, to, translationCache, _ref;
  if (ctx.isAtDefinition()) {
    to = ctx.definitionPattern();
    ctx.setAssignTo(irDefinition(expression.tea, translatedExpression));
    _ref = patternCompile(ctx, to, expression), precs = _ref.precs, assigns = _ref.assigns;
    translationCache = ctx.resetAssignTo();
    if (ctx.shouldDefer()) {
      ctx.addDeferredDefinition(ctx.deferReason().concat([to, expression]));
      return deferredExpression();
    }
    if (assigns.length === 0) {
      return malformed(to, 'Not an assignable pattern');
    }
    return join(translationCache, map(compileVariableAssignment, assigns));
  } else {
    return translatedExpression;
  }
};

patternCompile = function(ctx, pattern, matched) {
  var assigns, currentType, deferredConstraints, definedNames, dep, deps, id, name, precs, retainedConstraints, type, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
  _ref = expressionCompile(ctx, pattern), precs = _ref.precs, assigns = _ref.assigns;
  definedNames = ctx.definedNames();
  if (ctx.shouldDefer()) {
    for (_i = 0, _len = definedNames.length; _i < _len; _i++) {
      name = definedNames[_i].name;
      if (!ctx.arity(name)) {
        ctx.declare(name);
      }
    }
    return {};
  }
  if (pattern.tea) {
    unify(ctx, matched.tea.type, pattern.tea.type);
  }
  for (_j = 0, _len1 = definedNames.length; _j < _len1; _j++) {
    _ref1 = definedNames[_j], name = _ref1.name, id = _ref1.id, type = _ref1.type;
    currentType = substitute(ctx.substitution, type);
    deps = ctx.deferredNames();
    if (deps.length > 0) {
      ctx.addToDeferred({
        name: name,
        type: type,
        deps: map((function(_arg) {
          var name;
          name = _arg.name;
          return name;
        }), deps)
      });
      for (_k = 0, _len2 = deps.length; _k < _len2; _k++) {
        dep = deps[_k];
        ctx.addToDeferred({
          name: dep.name,
          type: dep.type,
          deps: [name]
        });
      }
      ctx.declare(name, {
        type: new TempType(type),
        id: id
      });
    } else {
      if (!ctx.isCurrentlyDeclared(name)) {
        ctx.declare(name, {
          id: id
        });
      }
      if (ctx.isTyped(name)) {
        unify(ctx, currentType.type, (freshInstance(ctx, ctx.type(name))).type);
      } else {
        _ref2 = deferConstraints(ctx, ctx.allBoundTypeVariables(), findFree(currentType), substituteList(ctx.substitution, matched.tea.constraints)), deferredConstraints = _ref2[0], retainedConstraints = _ref2[1];
        ctx.assignType(name, ctx.isAtDeferrableDefinition() ? quantifyUnbound(ctx, addConstraints(currentType, retainedConstraints)) : toForAll(currentType));
      }
    }
  }
  return {
    precs: precs != null ? precs : [],
    assigns: assigns != null ? assigns : []
  };
};

topLevelExpression = function(ctx, expression) {
  var compiled;
  compiled = expressionCompile(ctx, expression);
  return irDefinition(expression.tea, compiled);
};

topLevel = function(ctx, form) {
  return definitionList(ctx, pairs(_terms(form)));
};

definitionList = function(ctx, pairs) {
  var compiledPairs, lhs, rhs;
  compiledPairs = (function() {
    var _i, _len, _ref, _results;
    _results = [];
    for (_i = 0, _len = pairs.length; _i < _len; _i++) {
      _ref = pairs[_i], lhs = _ref[0], rhs = _ref[1];
      if (rhs) {
        _results.push(definitionPairCompile(ctx, lhs, rhs));
      } else {
        malformed(lhs, 'missing value in definition');
        _results.push(void 0);
      }
    }
    return _results;
  })();
  compiledPairs = join(compiledPairs, compileDeferred(ctx));
  resolveDeferredTypes(ctx);
  return concat(filter(_is, compiledPairs));
};

resolveDeferredTypes = function(ctx) {
  var canonicalType, name, names, type, types, unresolvedNames, _i, _j, _len, _len1, _ref, _ref1, _results;
  if (_notEmpty(ctx.deferredBindings())) {
    names = concatConcatMaps(map((function(_arg) {
      var name, type;
      name = _arg.name, type = _arg.type;
      return newMapWith(name, type);
    }), ctx.deferredBindings()));
    unresolvedNames = newMap();
    _ref = values(names);
    for (name in _ref) {
      types = _ref[name];
      if (canonicalType = ctx.type(name)) {
        for (_i = 0, _len = types.length; _i < _len; _i++) {
          type = types[_i];
          unify(ctx, type.type, (freshInstance(ctx, canonicalType)).type);
        }
      } else {
        addToMap(unresolvedNames, name, types);
      }
    }
    _ref1 = values(unresolvedNames);
    for (name in _ref1) {
      types = _ref1[name];
      canonicalType = toConstrained(ctx.freshTypeVariable(star));
      for (_j = 0, _len1 = types.length; _j < _len1; _j++) {
        type = types[_j];
        unify(ctx, canonicalType.type, type.type);
      }
    }
    _results = [];
    for (name in values(unresolvedNames)) {
      _results.push(ctx.assignType(name, quantifyAll(substitute(ctx.substitution, canonicalType))));
    }
    return _results;
  }
};

compileDeferred = function(ctx) {
  var compiledPairs, deferred, deferredCount, dependencyName, expression, lhs, prevSize, rhs, _i, _len, _ref, _ref1, _ref2;
  compiledPairs = [];
  if (_notEmpty(ctx.deferred())) {
    deferredCount = 0;
    while ((_notEmpty(ctx.deferred())) && deferredCount < ctx.deferred().length) {
      prevSize = ctx.deferred().length;
      _ref = deferred = ctx.deferred().shift(), expression = _ref[0], dependencyName = _ref[1], lhs = _ref[2], rhs = _ref[3];
      if (ctx.isDeclared(dependencyName)) {
        compiledPairs.push(definitionPairCompile(ctx, lhs, rhs));
      } else {
        ctx.addDeferredDefinition(deferred);
      }
      if (prevSize === ctx.deferred().length) {
        deferredCount++;
      }
    }
  }
  if (_notEmpty(ctx.deferred())) {
    _ref1 = ctx.deferred();
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      _ref2 = _ref1[_i], expression = _ref2[0], dependencyName = _ref2[1], lhs = _ref2[2], rhs = _ref2[3];
      if (ctx.isInTopScope()) {
        malformed(expression, "" + dependencyName + " is not defined");
      } else {
        ctx.doDefer(expression, dependencyName);
      }
    }
  }
  return concat(compiledPairs);
};

definitionPairCompile = function(ctx, pattern, value) {
  var compiled, wasDeferred;
  ctx.definePattern(pattern);
  compiled = expressionCompile(ctx, value);
  wasDeferred = ctx.shouldDefer();
  ctx.leaveDefinition();
  if (wasDeferred) {
    return void 0;
  } else {
    return compiled;
  }
};

ms = {};

ms.fn = ms_fn = function(ctx, call) {
  var args, body, compiledBody, compiledWheres, defs, docs, explicitType, isUsedParam, labelUsedParams, param, paramList, paramNames, paramTypeVars, paramTypes, params, type, wheres, _i, _len, _ref, _ref1;
  args = _arguments(call);
  paramList = args[0], defs = 2 <= args.length ? __slice.call(args, 1) : [];
  params = paramTupleIn(call, paramList);
  if (defs == null) {
    defs = [];
  }
  if (defs.length === 0) {
    return malformed(call, 'Missing function result');
  } else {
    _ref = partition(isComment, defs), docs = _ref[0], defs = _ref[1];
    map(labelComments, docs);
    if (isTypeAnnotation(defs[0])) {
      type = defs[0], body = defs[1], wheres = 3 <= defs.length ? __slice.call(defs, 2) : [];
    } else {
      body = defs[0], wheres = 2 <= defs.length ? __slice.call(defs, 1) : [];
    }
    paramNames = _names(params);
    if (ctx.isAtSimpleDefinition()) {
      ctx.declareArity(ctx.definitionName(), paramNames);
      if (type) {
        explicitType = quantifyUnbound(ctx, typeConstrainedCompile(ctx, type));
        ctx.assignType(ctx.definitionName(), explicitType);
      }
    }
    paramTypeVars = map((function() {
      return ctx.freshTypeVariable(star);
    }), params);
    paramTypes = map(__(toForAll, toConstrained), paramTypeVars);
    ctx.newLateScope();
    ctx.bindTypeVariables(map((function(_arg) {
      var name;
      name = _arg.name;
      return name;
    }), paramTypeVars));
    ctx.declareTypes(paramNames, paramTypes);
    for (_i = 0, _len = params.length; _i < _len; _i++) {
      param = params[_i];
      param.id = ctx.declarationId(_symbol(param));
    }
    compiledWheres = definitionList(ctx, pairs(wheres));
    if (body) {
      compiledBody = termCompile(ctx, body);
    }
    ctx.closeScope();
    isUsedParam = function(expression) {
      var _ref1;
      return (isName(expression)) && (_ref1 = _symbol(expression), __indexOf.call(paramNames, _ref1) >= 0);
    };
    labelUsedParams = function(expression) {
      return map(syntaxNameAs('', 'param'), filterAst(isUsedParam, expression));
    };
    map(labelUsedParams, join(docs, (body ? join([body], wheres) : wheres)));
    if (body && !isWellformed(body)) {
      return 'malformed';
    }
    return assignCompile(ctx, call, ctx.shouldDefer() ? deferredExpression() : (body && !body.tea ? malformed(body, 'Expression failed to type check') : void 0, call.tea = body ? new Constrained(body.tea.constraints, typeFn.apply(null, __slice.call(paramTypeVars).concat([(_ref1 = body.tea) != null ? _ref1.type : void 0]))) : freshInstance(ctx, explicitType), irFunction({
      name: (ctx.isAtSimpleDefinition() ? ctx.definitionName() : void 0),
      type: call.tea,
      params: paramNames,
      body: join(compiledWheres, [jsReturn(compiledBody)])
    })));
  }
};

ms.type = ms_type = function(ctx, call) {
  var alias, hasName, type;
  hasName = requireName(ctx, 'Name required to declare new type alias');
  alias = ctx.definitionName();
  if (!(isCapital({
    symbol: alias
  }))) {
    malformed(ctx.definitionPattern(), 'Type aliases must start with a capital letter');
  }
  type = _arguments(call)[0];
  ctx.addTypeAlias(alias, typeCompile(ctx, type));
  return jsNoop();
};

ms.data = ms_data = function(ctx, call) {
  var args, constr, constrType, constrValue, dataName, dataType, defs, fieldTypes, hasName, i, identifier, label, names, paramLabels, paramNames, paramTypes, params, typeArgLists, typeParamTuple, typeParams, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3;
  hasName = requireName(ctx, 'Name required to declare new algebraic data');
  args = _arguments(call);
  if (isTuple(args[0])) {
    _ref = args, typeParamTuple = _ref[0], args = 2 <= _ref.length ? __slice.call(_ref, 1) : [];
    typeParams = paramTupleIn(call, typeParamTuple);
  }
  if (typeParams == null) {
    typeParams = [];
  }
  defs = pairsLeft(isAtom, args);
  _ref1 = unzip(defs), names = _ref1[0], typeArgLists = _ref1[1];
  map(syntaxNewName('Type constructor name required'), names);
  if (!hasName) {
    return 'malformed';
  }
  dataName = ctx.definitionName();
  _ref2 = findDataType(ctx, typeArgLists, typeParams, dataName), fieldTypes = _ref2.fieldTypes, dataType = _ref2.dataType;
  for (i = _i = 0, _len = defs.length; _i < _len; i = ++_i) {
    _ref3 = defs[i], constr = _ref3[0], params = _ref3[1];
    paramTypes = fieldTypes[i];
    constrType = params ? typeFn.apply(null, join(paramTypes, [dataType])) : dataType;
    paramLabels = (_labeled(_terms(params || []))).map(_fst).map(_labelName);
    ctx.declare(constr.symbol, {
      type: quantifyUnbound(ctx, toConstrained(constrType)),
      arity: (params ? paramLabels : void 0)
    });
    constr.tea = constrType;
    for (i = _j = 0, _len1 = paramLabels.length; _j < _len1; i = ++_j) {
      label = paramLabels[i];
      ctx.declare("" + constr.symbol + "." + label, {
        arity: ["" + (constr.symbol[0].toLowerCase()) + constr.symbol.slice(1)],
        type: quantifyUnbound(ctx, toConstrained(typeFn(dataType, paramTypes[i])))
      });
    }
  }
  ctx.addTypeName(dataType);
  return concat((function() {
    var _k, _len2, _ref4, _results;
    _results = [];
    for (_k = 0, _len2 = defs.length; _k < _len2; _k++) {
      _ref4 = defs[_k], constr = _ref4[0], params = _ref4[1];
      identifier = validIdentifier(constr.symbol);
      paramLabels = (_labeled(_terms(params || []))).map(_fst).map(_labelName);
      paramNames = paramLabels.map(validIdentifier);
      constrValue = jsAssignStatement("" + identifier + "._value", params ? jsCall("" + paramNames.length, [
        jsFunction({
          params: paramNames,
          body: [jsReturn(jsNew(identifier, paramNames))]
        })
      ]) : jsNew(identifier, []));
      _results.push(join(translateDict(identifier, paramNames), [constrValue]));
    }
    return _results;
  })());
};

findDataType = function(ctx, typeArgLists, typeParams, dataName) {
  var dataKind, fieldTypes, foundKind, freshingSub, kind, kinds, name, type, typeArgs, typeParam, typeVars, varNameSet, varNames, _i, _len;
  varNames = map(_symbol, typeParams);
  varNameSet = arrayToSet(varNames);
  kinds = newMap();
  fieldTypes = (function() {
    var _i, _len, _results;
    _results = [];
    for (_i = 0, _len = typeArgLists.length; _i < _len; _i++) {
      typeArgs = typeArgLists[_i];
      if (typeArgs) {
        if (isRecord(typeArgs)) {
          _results.push((function() {
            var _j, _len1, _ref, _ref1, _results1;
            _ref = _snd(unzip(_labeled(_terms(typeArgs))));
            _results1 = [];
            for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
              type = _ref[_j];
              type = typeCompile(ctx, type);
              _ref1 = values(findFree(type));
              for (name in _ref1) {
                kind = _ref1[name];
                if (!inSet(varNameSet, name)) {
                  malformed(type, "Type variable " + name + " not declared");
                  throw new Error("Type variable " + name + " not declared");
                } else {
                  if (foundKind = lookupInMap(kinds, name)) {
                    if (!kindsEq(foundKind, kind)) {
                      malformed(type, "Type variable " + name + " must have the same kind");
                    }
                  } else {
                    addToMap(kinds, name, kind);
                  }
                }
              }
              _results1.push(type);
            }
            return _results1;
          })());
        } else {
          malformed(typeArgs, 'Required a record of types');
          _results.push(null);
        }
      } else {
        _results.push(null);
      }
    }
    return _results;
  })();
  for (_i = 0, _len = typeParams.length; _i < _len; _i++) {
    typeParam = typeParams[_i];
    if (!lookupInMap(kinds, _symbol(typeParam))) {
      malformed(typeParam, 'Data type parameter not used');
      throw new Error('Data type parameter not used');
    }
  }
  freshingSub = mapToSubstitution(mapMap((function(kind) {
    return ctx.freshTypeVariable(kind);
  }), kinds));
  dataKind = kindFnOfArgs.apply(null, map((function(name) {
    return lookupInMap(kinds, name);
  }), varNames));
  typeVars = map((function(name) {
    return new TypeVariable(name, lookupInMap(kinds, name));
  }), varNames);
  return {
    dataType: substitute(freshingSub, applyKindFn.apply(null, [new TypeConstr(dataName, dataKind)].concat(__slice.call(typeVars)))),
    fieldTypes: map((function(types) {
      if (types) {
        return substituteList(freshingSub, types);
      }
    }), fieldTypes)
  };
};

ms.record = ms_record = function(ctx, call) {
  var args, hasName, name, type, _i, _len, _ref, _ref1;
  args = _arguments(call);
  hasName = requireName(ctx, 'Name required to declare new record');
  _ref = _labeled(args);
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    _ref1 = _ref[_i], name = _ref1[0], type = _ref1[1];
    if (!name) {
      malformed(type, 'Label is required');
    }
    if (!type) {
      malformed(name, 'Missing type');
    }
    if (name && type) {
      syntaxType(type);
    }
  }
  if (args.length === 0) {
    malformed(call, 'Missing arguments');
  }
  if (!hasName) {
    return 'malformed';
  }
  return replicate(call, call_(token_('data'), [token_(ctx.definitionName()), tuple_(args)]));
};

ms["class"] = ms_class = function(ctx, call) {
  var classConstraint, constraintSeq, constraints, declarations, def, defs, docs, freshedDeclarations, hasName, methodDefinitions, name, paramList, paramNames, params, superClasses, wheres, _i, _len, _ref, _ref1, _ref2, _ref3, _ref4;
  hasName = requireName(ctx, 'Name required to declare a new class');
  _ref = _arguments(call), paramList = _ref[0], defs = 2 <= _ref.length ? __slice.call(_ref, 1) : [];
  params = paramTupleIn(call, paramList);
  paramNames = _names(params);
  _ref1 = partition(isComment, defs), docs = _ref1[0], defs = _ref1[1];
  constraintSeq = defs[0], wheres = 2 <= defs.length ? __slice.call(defs, 1) : [];
  if (!isSeq(constraintSeq)) {
    wheres = defs;
    constraints = [];
  } else {
    constraints = typeConstraintsCompile(ctx, _terms(constraintSeq));
  }
  superClasses = map((function(_arg) {
    var className;
    className = _arg.className;
    return className;
  }), constraints);
  methodDefinitions = pairs(wheres);
  ctx.newScope();
  ctx.bindTypeVariables(paramNames);
  definitionList(ctx, methodDefinitions);
  declarations = ctx.currentDeclarations();
  ctx.closeScope();
  for (_i = 0, _len = methodDefinitions.length; _i < _len; _i++) {
    _ref2 = methodDefinitions[_i], name = _ref2[0], def = _ref2[1];
    if ((_ref3 = lookupInMap(declarations, name)) != null) {
      _ref3.def = def;
    }
  }
  if (hasName) {
    name = ctx.definitionName();
    if (ctx.isClassDefined(name)) {
      return malformed('class already defined', ctx.definitionPattern());
    } else {
      _ref4 = findClassType(ctx, name, paramNames, declarations), classConstraint = _ref4.classConstraint, freshedDeclarations = _ref4.freshedDeclarations;
      ctx.addClass(name, classConstraint, superClasses, freshedDeclarations);
      declareMethods(ctx, classConstraint, freshedDeclarations);
      return translateDict(name, keysOfMap(freshedDeclarations), superClasses);
    }
  } else {
    return 'malformed';
  }
};

findClassType = function(ctx, className, paramNames, methods) {
  var arity, classParam, def, foundKind, freshingSub, kindSoFar, kinds, method, name, param, type, vars, _i, _len, _ref, _ref1;
  kinds = mapMap((function() {
    return void 0;
  }), arrayToSet(paramNames));
  _ref = values(methods);
  for (name in _ref) {
    _ref1 = _ref[name], arity = _ref1.arity, type = _ref1.type, def = _ref1.def;
    for (_i = 0, _len = paramNames.length; _i < _len; _i++) {
      param = paramNames[_i];
      vars = findFree(type.type);
      kindSoFar = lookupInMap(kinds, param);
      foundKind = lookupInMap(vars, param);
      if (!foundKind) {
        malformed(def, 'Method must include class parameter in its type');
      }
      if (kindSoFar && !kindsEq(foundKind, kindSoFar)) {
        malformed(def, 'All methods must use the class paramater of the same kind');
      }
      replaceInMap(kinds, param, foundKind);
    }
  }
  freshingSub = mapToSubstitution(mapMap((function(kind) {
    return ctx.freshTypeVariable(kind);
  }), kinds));
  classParam = function(param) {
    return substitute(freshingSub, new TypeVariable(param, lookupInMap(kinds, param)));
  };
  method = function(_arg) {
    var arity, def, type;
    arity = _arg.arity, type = _arg.type, def = _arg.def;
    return {
      arity: arity,
      def: def,
      type: substitute(freshingSub, type)
    };
  };
  return {
    classConstraint: new ClassConstraint(className, new Types(map(classParam, paramNames))),
    freshedDeclarations: mapMap(method, methods)
  };
};

declareMethods = function(ctx, classConstraint, methodDeclarations) {
  var arity, name, type, _ref, _ref1;
  _ref = values(methodDeclarations);
  for (name in _ref) {
    _ref1 = _ref[name], arity = _ref1.arity, type = _ref1.type;
    type = quantifyUnbound(ctx, addConstraints(freshInstance(ctx, type), [classConstraint]));
    ctx.declare(name, {
      arity: arity,
      type: type
    });
  }
};

ms.instance = ms_instance = function(ctx, call) {
  var classDefinition, className, constraintSeq, constraints, definitions, defs, freshConstraints, freshInstanceType, hasName, instance, instanceConstraint, instanceName, instanceType, lhs, methodTypes, methods, methodsDeclarations, rhs, superClassInstances, wheres, _ref;
  hasName = requireName(ctx, 'Name required to declare a new instance');
  _ref = _arguments(call), instanceConstraint = _ref[0], defs = 2 <= _ref.length ? __slice.call(_ref, 1) : [];
  if (!isCall(instanceConstraint)) {
    return malformed(call, 'Instance requires a class constraint');
  } else {
    instanceType = typeConstraintCompile(ctx, instanceConstraint);
  }
  constraintSeq = defs[0], wheres = 2 <= defs.length ? __slice.call(defs, 1) : [];
  if (!isSeq(constraintSeq)) {
    wheres = defs;
    constraints = [];
  } else {
    constraints = typeConstraintsCompile(ctx, _terms(constraintSeq));
  }
  className = instanceType.className;
  classDefinition = ctx.classNamed(className);
  superClassInstances = findSuperClassInstances(ctx, instanceType.types, classDefinition);
  if (hasName) {
    instanceName = ctx.definitionName();
    ctx.newScope();
    freshInstanceType = assignMethodTypes(ctx, instanceName, classDefinition, instanceType, constraints);
    freshConstraints = freshInstanceType.constraints;
    definitions = pairs(wheres);
    methodsDeclarations = definitionList(ctx, prefixWithInstanceName(definitions, instanceName));
    ctx.closeScope();
    methods = map((function(_arg) {
      var rhs;
      rhs = _arg.rhs;
      return rhs;
    }), methodsDeclarations);
    methodTypes = (function() {
      var _i, _len, _ref1, _results;
      _results = [];
      for (_i = 0, _len = definitions.length; _i < _len; _i++) {
        _ref1 = definitions[_i], lhs = _ref1[0], rhs = _ref1[1];
        _results.push(rhs.tea);
      }
      return _results;
    })();
    instance = new Constrained(freshConstraints, new ClassConstraint(instanceType.className, freshInstanceType.type));
    ctx.addInstance(instanceName, instance);
    return jsVarDeclaration(validIdentifier(instanceName), irDefinition(new Constrained(freshConstraints, (tupleOfTypes(methodTypes)).type), jsNew(className, join(superClassInstances, methods))));
  } else {
    return 'malformed';
  }
};

assignMethodTypes = function(ctx, instanceName, classDeclaration, instanceType, instanceConstraints) {
  var arity, freshInstanceType, freshType, instanceSpecificType, name, prefixedName, quantifiedType, sub, type, _ref, _ref1;
  freshInstanceType = freshInstance(ctx, quantifyUnbound(ctx, new Constrained(instanceConstraints, instanceType.types)));
  sub = mostGeneralUnifier(classDeclaration.constraint.types, freshInstanceType.type);
  ctx.bindTypeVariables(setToArray(findFree(freshInstanceType)));
  _ref = values(classDeclaration.declarations);
  for (name in _ref) {
    _ref1 = _ref[name], arity = _ref1.arity, type = _ref1.type;
    freshType = freshInstance(ctx, type);
    instanceSpecificType = substitute(sub, freshType);
    quantifiedType = quantifyUnbound(ctx, instanceSpecificType);
    prefixedName = instancePrefix(instanceName, name);
    ctx.declareArity(prefixedName, arity);
    ctx.assignType(prefixedName, quantifiedType);
  }
  return freshInstanceType;
};

prefixWithInstanceName = function(definitionPairs, instanceName) {
  var lhs, rhs, _i, _len, _ref, _results;
  _results = [];
  for (_i = 0, _len = definitionPairs.length; _i < _len; _i++) {
    _ref = definitionPairs[_i], lhs = _ref[0], rhs = _ref[1];
    if ((syntaxNewName('Method name required', lhs)) === true) {
      _results.push([token_(instancePrefix(instanceName, lhs.symbol)), rhs]);
    } else {
      _results.push([lhs, rhs]);
    }
  }
  return _results;
};

instancePrefix = function(instanceName, methodName) {
  return "" + instanceName + "_" + methodName;
};

findSuperClassInstances = function(ctx, instanceTypes, classDefinition) {
  var constraint, superConstraints, toConstraint, _i, _len, _results;
  toConstraint = function(superName) {
    return new ClassConstraint(superName, instanceTypes);
  };
  superConstraints = map(toConstraint, classDefinition.supers);
  _results = [];
  for (_i = 0, _len = superConstraints.length; _i < _len; _i++) {
    constraint = superConstraints[_i];
    _results.push(instanceDictFor(ctx, constraint));
  }
  return _results;
};

ms.match = ms_match = function(ctx, call) {
  var assigns, cases, compiledCases, compiledResult, constraints, errorMessage, pattern, precs, result, resultType, subject, subjectCompiled, translationCache, varNames, _ref;
  _ref = _arguments(call), subject = _ref[0], cases = 2 <= _ref.length ? __slice.call(_ref, 1) : [];
  if (!subject) {
    return malformed(call, 'match `subject` missing');
  }
  if (cases.length % 2 !== 0) {
    return malformed(call, 'match missing result for last pattern');
  }
  subjectCompiled = termCompile(ctx, subject);
  resultType = ctx.freshTypeVariable(star);
  ctx.setAssignTo(subjectCompiled);
  varNames = [];
  constraints = [];
  errorMessage = ctx.definitionName() != null ? " in " + (ctx.definitionName()) : "";
  compiledCases = conditional((function() {
    var _i, _len, _ref1, _ref2, _ref3, _results;
    _ref1 = pairs(cases);
    _results = [];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      _ref2 = _ref1[_i], pattern = _ref2[0], result = _ref2[1];
      ctx.newScope();
      ctx.defineNonDeferrablePattern(pattern);
      _ref3 = patternCompile(ctx, pattern, subject), precs = _ref3.precs, assigns = _ref3.assigns;
      ctx.setAssignTo(void 0);
      compiledResult = termCompile(ctx, result);
      ctx.resetAssignTo();
      ctx.leaveDefinition();
      ctx.closeScope();
      if (ctx.shouldDefer()) {
        continue;
      }
      unify(ctx, resultType, result.tea.type);
      constraints.push.apply(constraints, result.tea.constraints);
      varNames.push.apply(varNames, findDeclarables(precs));
      _results.push(matchBranchTranslate(precs, assigns, compiledResult));
    }
    return _results;
  })(), "throw new Error('match failed to match" + errorMessage + "');");
  translationCache = ctx.resetAssignTo();
  call.tea = new Constrained(constraints, resultType);
  return assignCompile(ctx, call, iife(concat(filter(_is, [translationCache, varList(varNames), compiledCases]))));
};

ms.format = ms_format = function(ctx, call) {
  var args, compiled, compiledArgs, formatString, formatStringToken, formattedArgs, i, match, matched, prefix, symbol, type, typeTable, types, _ref;
  typeTable = {
    n: numType,
    i: numType,
    s: stringType,
    c: charType
  };
  _ref = _arguments(call), formatStringToken = _ref[0], args = 2 <= _ref.length ? __slice.call(_ref, 1) : [];
  types = [];
  formatString = _stringValue(formatStringToken);
  while (formatString.length > 0) {
    match = formatString.match(/^(.*?(?:^|[^\\]))\%(.)/);
    if (!match) {
      break;
    }
    matched = match[0], prefix = match[1], symbol = match[2];
    if (symbol in typeTable) {
      types.push({
        type: typeTable[symbol],
        symbol: symbol,
        prefix: prefix
      });
    } else {
      malformed(formatString, "Found an unsupported control character " + symbol);
    }
    formatString = formatString.slice(matched.length);
  }
  if (args.length > types.length) {
    malformed(call, "Too many arguments to format");
  }
  call.tea = toConstrained(stringType);
  compiledArgs = termsCompile(ctx, args);
  formattedArgs = (function() {
    var _i, _len, _ref1, _results;
    _results = [];
    for (i = _i = 0, _len = types.length; _i < _len; i = ++_i) {
      _ref1 = types[i], type = _ref1.type, symbol = _ref1.symbol, prefix = _ref1.prefix;
      if (!args[i]) {
        continue;
      }
      compiled = compiledArgs[i];
      unify(ctx, type, args[i].tea.type);
      _results.push([
        string_(prefix), (function() {
          switch (symbol) {
            case 's':
              return compiled;
            case 'c':
              return compiled;
            case 'n':
              return compiled;
            case 'i':
              return jsUnary("~", jsUnary("~", compiled));
          }
        })()
      ]);
    }
    return _results;
  })();
  return assignCompile(ctx, call, jsBinaryMulti("+", join(concat(formattedArgs), [string_(formatString)])));
};

ms.macro = ms_macro = function(ctx, call) {
  var compiledMacro, hasName, macroName, paramNames, paramTuple, params, rest, type, _ref;
  hasName = requireName(ctx, 'Name required to declare a new instance');
  _ref = _arguments(call), paramTuple = _ref[0], type = _ref[1], rest = 3 <= _ref.length ? __slice.call(_ref, 2) : [];
  if (hasName) {
    macroName = ctx.definitionName();
    if (ctx.macros()[macroName]) {
      return malformed(call, "Macro with this name already defined");
    }
    if (!isTypeAnnotation(type)) {
      return malformed(call, "Type annotation required");
    }
    params = _terms(paramTuple);
    paramNames = map(_symbol, params);
    ctx.declare(macroName, {
      arity: paramNames,
      type: quantifyUnbound(ctx, typeConstrainedCompile(ctx, type))
    });
    compiledMacro = translateToJs(translateIr(ctx, termCompile(ctx, call_(token_('fn'), join([paramTuple], rest)))));
    ctx.addMacro(macroName, simpleMacro(eval(compiledMacro)));
    params = map(token_, paramNames);
    return fn_(params, call_(token_(macroName), params));
  }
};

simpleMacro = function(macroFn) {
  return function(ctx, call) {
    var args;
    operatorCompile(ctx, call);
    args = termsCompile(ctx, (_arguments(call)).slice(0, +macroFn.length + 1 || 9e9));
    callTyping(ctx, call);
    return assignCompile(ctx, call, macroFn.apply(null, args));
  };
};

_ref = ['binary', 'ternary', 'unary', 'access', 'call'];
_fn = function(jsMethod) {
  return ms["Js." + jsMethod] = function(ctx, call) {
    var compatibles, compiled, i, term, terms;
    call.tea = toConstrained(typeConstant("JS"));
    terms = _arguments(call);
    compatibles = (function() {
      var _j, _len1, _results;
      _results = [];
      for (i = _j = 0, _len1 = terms.length; _j < _len1; i = ++_j) {
        term = terms[i];
        compiled = termCompile(ctx, term);
        _results.push(irJsCompatible(term.tea, compiled));
      }
      return _results;
    })();
    return jsCall("js" + (jsMethod[0].toUpperCase()) + jsMethod.slice(1), compatibles);
  };
};
for (_i = 0, _len = _ref.length; _i < _len; _i++) {
  jsMethod = _ref[_i];
  _fn(jsMethod);
}

ms['=='] = ms_eq = function(ctx, call) {
  var a, b, compiledA, compiledB, _ref1;
  _ref1 = _arguments(call), a = _ref1[0], b = _ref1[1];
  operatorCompile(ctx, call);
  compiledA = termCompile(ctx, a);
  compiledB = termCompile(ctx, b);
  callTyping(ctx, call);
  return assignCompile(ctx, call, jsBinary("===", compiledA, compiledB));
};

ms.Set = ms_Set = function(ctx, call) {
  var compiledItems, hashset, items;
  if (hashset = ctx.assignTo()) {
    throw new Error("matching on sets not supported yet");
  } else {
    items = _arguments(call);
    compiledItems = uniformCollectionCompile(ctx, call, items, hashsetType);
    return assignCompile(ctx, call, irSet(compiledItems));
  }
};

ms.Map = ms_Map = function(ctx, call) {
  var args, compiledItems, compiledLabels, hashset, items, keyType, labels, _ref1;
  if (hashset = ctx.assignTo()) {
    throw new Error("matching on sets not supported yet");
  } else {
    args = _arguments(call);
    if (args.length % 2 !== 0) {
      malformed(args[args.length - 1], 'Missing value for key');
    }
    _ref1 = unzip(pairs(args)), labels = _ref1[0], items = _ref1[1];
    compiledLabels = uniformCollectionItemsCompile(ctx, labels);
    keyType = applyKindFn(hashmapType, compiledLabels.itemType);
    compiledItems = uniformCollectionCompile(ctx, call, items, keyType, compiledLabels.constraints);
    return assignCompile(ctx, call, irMap(compiledLabels.compiled, compiledItems));
  }
};

builtInMacros = function() {
  var copy, key, val;
  copy = {};
  for (key in ms) {
    val = ms[key];
    copy[key] = val;
  }
  return copy;
};

matchBranchTranslate = function(precs, assigns, compiledResult) {
  var conds, furtherHoistable, hoistedWheres, preassigns, _ref1, _ref2;
  _ref1 = constructCond(precs), conds = _ref1.conds, preassigns = _ref1.preassigns;
  _ref2 = hoistWheres([], assigns), hoistedWheres = _ref2[0], furtherHoistable = _ref2[1];
  return [conds, concat([map(compileVariableAssignment, join(preassigns, assigns)), [jsReturn(compiledResult)]])];
};

iife = function(body) {
  return jsCall(jsFunction({
    params: [],
    body: body
  }), []);
};

varList = function(varNames) {
  if (varNames.length > 0) {
    return jsVarDeclarations(varNames);
  } else {
    return null;
  }
};

conditional = function(condCasePairs, elseCase) {
  var branch, cond, _ref1;
  if (condCasePairs.length === 1) {
    _ref1 = condCasePairs[0], cond = _ref1[0], branch = _ref1[1];
    if (cond === 'true') {
      return branch;
    }
  }
  return jsConditional(condCasePairs, elseCase);
};

paramTupleIn = function(call, expression) {
  var params;
  if (!expression || !isTuple(expression)) {
    malformed(call, 'Missing paramater list');
    params = [];
  } else {
    params = _terms(expression);
    map(syntaxNewName('Parameter name expected'), params);
  }
  return params;
};

quantifyUnbound = function(ctx, type) {
  var vars;
  vars = subtractSets(findFree(type), ctx.allBoundTypeVariables());
  return quantify(vars, type);
};

deferConstraints = function(ctx, fixedVars, quantifiedVars, constraints) {
  var deferred, isFixed, reducedConstraints, retained, _ref1;
  reducedConstraints = reduceConstraints(ctx, constraints);
  if (!reducedConstraints) {
    throw new Error("could not reduce constraints in deferConstraints");
  }
  isFixed = function(constraint) {
    return isSubset(fixedVars, findFree(constraint));
  };
  _ref1 = partition(isFixed, reducedConstraints), deferred = _ref1[0], retained = _ref1[1];
  return [deferred, retained];
};

reduceConstraints = function(ctx, constraints) {
  var normalized;
  normalized = normalizeConstraints(ctx, constraints);
  if (normalized) {
    return simplifyConstraints(ctx, normalized);
  } else {
    return null;
  }
};

normalizeConstraints = function(ctx, constraints) {
  var constraint, normalized;
  normalized = concat((function() {
    var _j, _len1, _results;
    _results = [];
    for (_j = 0, _len1 = constraints.length; _j < _len1; _j++) {
      constraint = constraints[_j];
      _results.push(normalizeConstraint(ctx, constraint));
    }
    return _results;
  })());
  if (all(normalized)) {
    return normalized;
  } else {
    return null;
  }
};

normalizeConstraint = function(ctx, constraint) {
  var instanceContraints;
  if (isNormalizedConstraint(constraint)) {
    return [constraint];
  } else {
    instanceContraints = constraintsFromInstance(ctx, constraint);
    if (instanceContraints) {
      return normalizeConstraints(ctx, instanceContraints);
    } else {
      throw new Error("no instance found to satisfy " + (safePrintType(constraint)));
      return null;
    }
  }
};

simplifyConstraints = function(ctx, constraints) {
  var constraint, i, requiredConstraints, _j, _len1;
  requiredConstraints = [];
  for (i = _j = 0, _len1 = constraints.length; _j < _len1; i = ++_j) {
    constraint = constraints[i];
    if (!entail(ctx, join(requiredConstraints, constraints.slice(i + 1)), constraint)) {
      requiredConstraints.push(constraint);
    }
  }
  return requiredConstraints;
};

entail = function(ctx, constraints, constraint) {
  var c, instanceContraints, superClassConstraint, _j, _k, _len1, _len2, _ref1;
  for (_j = 0, _len1 = constraints.length; _j < _len1; _j++) {
    c = constraints[_j];
    _ref1 = constraintsFromSuperClasses(ctx, c);
    for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
      superClassConstraint = _ref1[_k];
      if (typeEq(superClassConstraint, constraint)) {
        return true;
      }
    }
  }
  instanceContraints = constraintsFromInstance(ctx, constraint);
  if (instanceContraints) {
    return allMap((function(c) {
      return entail(ctx, constraints, c);
    }), instanceContraints);
  } else {
    return false;
  }
};

constraintsFromSuperClasses = function(ctx, constraint) {
  var className, s, types;
  className = constraint.className, types = constraint.types;
  return join([constraint], concat((function() {
    var _j, _len1, _ref1, _results;
    _ref1 = (ctx.classNamed(className)).supers;
    _results = [];
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      s = _ref1[_j];
      _results.push(constraintsFromSuperClasses(ctx, new ClassConstraint(s, types)));
    }
    return _results;
  })()));
};

constraintsFromInstance = function(ctx, constraint) {
  var className, instance, substitution, type, _j, _len1, _ref1;
  className = constraint.className, type = constraint.type;
  _ref1 = (ctx.classNamed(className)).instances;
  for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
    instance = _ref1[_j];
    substitution = toMatchTypes(instance.type.type.types, constraint.types);
    if (substitution) {
      return map((function(c) {
        return substitute(substitution, c);
      }), instance.type.constraints);
    }
  }
  return null;
};

_names = function(list) {
  return map(_symbol, list);
};

findDeclarables = function(precs) {
  return map(__(_fst, _cache), filter(_cache, precs));
};

combinePatterns = function(list) {
  return {
    precs: concat(map(_precs, filter(_precs, list))),
    assigns: concat(map(_assigns, filter(_assigns, list)))
  };
};

_precs = function(_arg) {
  var precs;
  precs = _arg.precs;
  return precs;
};

_assigns = function(_arg) {
  var assigns;
  assigns = _arg.assigns;
  return assigns;
};

_cache = function(_arg) {
  var cache;
  cache = _arg.cache;
  return cache;
};

cache_ = function(x) {
  return {
    cache: x
  };
};

cond_ = function(x) {
  return {
    cond: x
  };
};

malformed = function(expression, message) {
  expression.malformed = message;
  return jsMalformed(message);
};

isWellformed = function(expression) {
  var term, _j, _len1, _ref1;
  if (expression.malformed) {
    return false;
  } else {
    if (isForm(expression)) {
      _ref1 = _terms(expression);
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        term = _ref1[_j];
        if (!isWellformed(term)) {
          return false;
        }
      }
    }
    return true;
  }
};

translateDict = function(dictName, fieldNames, additionalFields) {
  var accessors, allFieldNames, constrFn, paramAssigns;
  if (additionalFields == null) {
    additionalFields = [];
  }
  allFieldNames = join(additionalFields, fieldNames);
  paramAssigns = allFieldNames.map(function(name) {
    return jsAssignStatement(jsAccess("this", name), validIdentifier(name));
  });
  constrFn = jsFunction({
    name: dictName,
    params: map(validIdentifier, allFieldNames),
    body: paramAssigns
  });
  accessors = fieldNames.map(function(name) {
    return jsAssignStatement(jsAccess(dictName, name), jsFunction({
      name: validIdentifier(name),
      params: ["dict"],
      body: [jsReturn(jsAccess("dict", name))]
    }));
  });
  return join([constrFn], accessors);
};

requireName = function(ctx, message) {
  if (ctx.isAtDefinition()) {
    return syntaxNewName(message, ctx.definitionPattern());
  } else {
    malformed(call, message);
    return false;
  }
};

atomCompile = function(ctx, atom) {
  var id, label, pattern, symbol, translation, type, _ref1;
  symbol = atom.symbol, label = atom.label;
  _ref1 = (function() {
    switch (label) {
      case 'numerical':
        return numericalCompile(ctx, symbol);
      case 'regex':
        return regexCompile(ctx, symbol);
      case 'char':
        return charCompile(ctx, atom, symbol);
      case 'string':
        return {
          type: toConstrained(stringType),
          translation: symbol,
          pattern: literalPattern(ctx, symbol)
        };
      default:
        return nameCompile(ctx, atom, symbol);
    }
  })(), type = _ref1.type, id = _ref1.id, translation = _ref1.translation, pattern = _ref1.pattern;
  if (type) {
    atom.tea = type;
  }
  if (id != null) {
    atom.id = id;
  }
  if (ctx.isOperator()) {
    labelOperator(atom);
  }
  if (ctx.assignTo()) {
    return pattern;
  } else {
    return assignCompile(ctx, atom, translation);
  }
};

nameCompile = function(ctx, atom, symbol) {
  var contextType, exp, id, type, _ref1;
  contextType = ctx.type(symbol);
  if (exp = ctx.assignTo()) {
    if (atom.label === 'const') {
      if (contextType) {
        return {
          type: freshInstance(ctx, ctx.type(symbol)),
          pattern: constPattern(ctx, symbol)
        };
      } else {
        ctx.doDefer(atom, symbol);
        return {
          pattern: []
        };
      }
    } else {
      atom.label = 'name';
      id = (_ref1 = ctx.declarationId(symbol)) != null ? _ref1 : ctx.freshId();
      type = toConstrained(ctx.freshTypeVariable(star));
      ctx.bindTypeVariables([type.type.name]);
      ctx.addToDefinedNames({
        name: symbol,
        id: id,
        type: type
      });
      return {
        type: type,
        id: id,
        pattern: {
          assigns: [[validIdentifier(symbol), exp]]
        }
      };
    }
  } else {
    if (contextType && !(contextType instanceof TempType)) {
      type = freshInstance(ctx, contextType);
      return {
        id: ctx.declarationId(symbol),
        type: type,
        translation: nameTranslate(ctx, atom, symbol, type)
      };
    } else if (ctx.isInsideLateScope() && (ctx.isDeclared(symbol)) || contextType instanceof TempType) {
      type = toConstrained(ctx.freshTypeVariable(star));
      ctx.addToDeferredNames({
        name: symbol,
        type: type
      });
      return {
        id: ctx.declarationId(symbol),
        type: type,
        translation: nameTranslate(ctx, atom, symbol, type)
      };
    } else {
      ctx.doDefer(atom, symbol);
      return {
        translation: deferredExpression()
      };
    }
  }
};

constPattern = function(ctx, symbol) {
  var exp;
  exp = ctx.assignTo();
  return {
    precs: [
      cond_((function() {
        switch (symbol) {
          case 'True':
            return exp;
          case 'False':
            return jsUnary("!", exp);
          default:
            return jsBinary("instanceof", exp, validIdentifier(symbol));
        }
      })())
    ]
  };
};

nameTranslate = function(ctx, atom, symbol, type) {
  if (atom.label === 'const') {
    switch (symbol) {
      case 'True':
        return 'true';
      case 'False':
        return 'false';
      default:
        return jsAccess(validIdentifier(symbol), "_value");
    }
  } else if (ctx.isMethod(symbol, type)) {
    return irMethod(type, symbol);
  } else {
    return validIdentifier(symbol);
  }
};

numericalCompile = function(ctx, symbol) {
  var translation;
  translation = symbol[0] === '~' ? jsUnary("-", symbol.slice(1)) : symbol;
  return {
    type: toConstrained(typeConstant('Num')),
    translation: translation,
    pattern: literalPattern(ctx, translation)
  };
};

regexCompile = function(ctx, symbol) {
  return {
    type: toConstrained(typeConstant('Regex')),
    translation: symbol,
    pattern: ctx.assignTo() ? {
      precs: [cond_(jsBinary("===", jsAccess(ctx.assignTo(), "string"), "" + symbol + ".string"))]
    } : void 0
  };
};

specialCharacters = "\\newline \\tab \\formfeed \\backspace \\return".split(' ');

charCompile = function(ctx, atom, symbol) {
  var translation;
  translation = symbol.length === 2 ? '"' + symbol[1] + '"' : symbol === "\\space" ? ' ' : __indexOf.call(specialCharacters, symbol) >= 0 ? "\"\\" + symbol[1] + "\"" : /^\\x[a-fA-F0-9]{2}/.test(symbol) ? '"' + symbol + '"' : /^\\u[a-fA-F0-9]{4}/.test(symbol) ? '"' + symbol + '"' : (malformed(atom, 'Unrecognized character'), '');
  return {
    type: toConstrained(charType),
    translation: translation,
    pattern: literalPattern(ctx, translation)
  };
};

literalPattern = function(ctx, translation) {
  if (ctx.assignTo()) {
    return {
      precs: [cond_(jsBinary("===", ctx.assignTo(), translation))]
    };
  }
};

deferredExpression = function() {
  return {
    js: 'deferred'
  };
};

syntaxType = function(expression) {
  if (isName(expression)) {
    return expression.label = isCapital ? 'typename' : 'typevar';
  } else if (isTuple(expression)) {
    return map(syntaxType, _terms(expression));
  } else if (isCall(expression)) {
    syntaxNameAs('Constructor name required', 'typecons', _operator(expression));
    return map(syntaxType, _arguments(expression));
  }
};

syntaxNewName = function(message, atom) {
  var curried;
  curried = function(atom) {
    return syntaxNameAs(message, 'name', atom);
  };
  if (atom) {
    return curried(atom);
  } else {
    return curried;
  }
};

syntaxNameAs = function(message, label, atom) {
  var curried;
  curried = function(atom) {
    if (isName(atom)) {
      atom.label = label;
      return true;
    } else {
      return malformed(atom, message);
    }
  };
  if (atom) {
    return curried(atom);
  } else {
    return curried;
  }
};

call_ = function(op, args) {
  return concat([tokenize('('), [op], args, tokenize(')')]);
};

tuple_ = function(list) {
  return concat([tokenize('['), list, tokenize(']')]);
};

fn_ = function(params, body) {
  return call_(token_('fn'), [tuple_(params), body]);
};

token_ = function(string) {
  return (tokenize(string))[0];
};

string_ = function(string) {
  return "\"" + string + "\"";
};

translateIr = function(ctx, irAst) {
  return walkIr(irAst, function(ast) {
    var name, node, walked;
    if (ast.ir) {
      return ast.ir(ctx, ast);
    } else {
      walked = {};
      for (name in ast) {
        node = ast[name];
        if (name !== 'js') {
          walked[name] = node && translateIr(ctx, node);
        }
      }
      walked.js = ast.js;
      return walked;
    }
  });
};

irDefinition = function(type, expression) {
  return {
    ir: irDefinitionTranslate,
    type: type,
    expression: expression
  };
};

irDefinitionTranslate = function(ctx, _arg) {
  var className, classParamNames, classParams, constraint, counter, expression, finalType, names, reducedConstraints, type, typeMap, _j, _len1;
  type = _arg.type, expression = _arg.expression;
  finalType = substitute(ctx.substitution, type);
  reducedConstraints = reduceConstraints(ctx, finalType.constraints);
  counter = {};
  classParams = newMap();
  for (_j = 0, _len1 = reducedConstraints.length; _j < _len1; _j++) {
    constraint = reducedConstraints[_j];
    if (!(!isAlreadyParametrized(ctx, constraint))) {
      continue;
    }
    className = constraint.className;
    names = typeNamesOfNormalized(constraint);
    typeMap = nestedLookupInMap(classParams, names);
    if (!typeMap) {
      nestedAddToMap(classParams, names, (typeMap = newMap()));
    }
    addToMap(typeMap, className, "_" + className + "_" + (counter[className] != null ? counter[className] : counter[className] = 0, ++counter[className]));
  }
  ctx.addClassParams(classParams);
  classParamNames = concatMap(mapToArray, mapToArray(classParams));
  if (_notEmpty(classParamNames)) {
    if (expression.ir === irFunctionTranslate) {
      return irFunctionTranslate(ctx, {
        name: expression.name,
        params: join(classParamNames, expression.params),
        body: expression.body
      });
    } else {
      return jsFunction({
        params: classParamNames,
        body: [jsReturn(translateIr(ctx, expression))]
      });
    }
  } else {
    return translateIr(ctx, expression);
  }
};

irCall = function(type, op, args) {
  return {
    ir: irCallTranslate,
    type: type,
    op: op,
    args: args
  };
};

irCallTranslate = function(ctx, _arg) {
  var args, classParams, finalType, op, type;
  type = _arg.type, op = _arg.op, args = _arg.args;
  finalType = substitute(ctx.substitution, type);
  classParams = op.ir === irMethodTranslate ? [] : dictsForConstraint(ctx, finalType.constraints);
  return jsCall(translateIr(ctx, op), join(classParams, translateIr(ctx, args)));
};

irMethod = function(type, name) {
  return {
    ir: irMethodTranslate,
    type: type,
    name: name
  };
};

irMethodTranslate = function(ctx, _arg) {
  var dict, finalType, name, resolvedMethod, type;
  type = _arg.type, name = _arg.name;
  finalType = substitute(ctx.substitution, type);
  resolvedMethod = (function() {
    var _j, _len1, _ref1, _results;
    _ref1 = dictsForConstraint(ctx, finalType.constraints);
    _results = [];
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      dict = _ref1[_j];
      _results.push(jsAccess(dict, name));
    }
    return _results;
  })();
  if (resolvedMethod.length > 1) {
    throw new Error("expected one constraint on a method");
  } else if (resolvedMethod.length === 1) {
    return resolvedMethod[0];
  } else {
    return method;
  }
};

dictsForConstraint = function(ctx, constraints) {
  var constraint, _j, _len1, _results;
  _results = [];
  for (_j = 0, _len1 = constraints.length; _j < _len1; _j++) {
    constraint = constraints[_j];
    _results.push(dictForConstraint(ctx, constraint));
  }
  return _results;
};

dictForConstraint = function(ctx, constraint) {
  var constraints;
  if (isNormalizedConstraint(constraint)) {
    return (ctx.classParamNameFor(constraint)) || findSubClassParam(ctx, constraint);
  } else if (_notEmpty((constraints = (constraintsFromInstance(ctx, constraint)) || []))) {
    return jsCall(instanceDictFor(ctx, constraint), dictsForConstraint(ctx, constraints));
  } else {
    return instanceDictFor(ctx, constraint);
  }
};

findSubClassParam = function(ctx, constraint) {
  var chain, className, dict, toClassName, _ref1;
  toClassName = function(c) {
    return c.className;
  };
  _ref1 = values(ctx.classParamsForType(constraint));
  for (className in _ref1) {
    dict = _ref1[className];
    if (chain = findSuperClassChain(ctx, className, constraint.className)) {
      return accessList(dict, chain);
    }
  }
  throw new Error("Couldn't find dict for " + (safePrintType(constraint)));
};

findSuperClassChain = function(ctx, className, targetClassName) {
  var chain, s, _j, _len1, _ref1;
  _ref1 = (ctx.classNamed(className)).supers;
  for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
    s = _ref1[_j];
    if (s === targetClassName) {
      return [s];
    } else if (chain = findSuperClassChain(ctx, s, targetClassName)) {
      return join([s], chain);
    }
  }
  return void 0;
};

typeNamesOfNormalized = function(constraint) {
  return map((function(_arg) {
    var name;
    name = _arg.name;
    return name;
  }), constraint.types.types);
};

accessList = function(what, list) {
  var first, rest;
  first = list[0], rest = 2 <= list.length ? __slice.call(list, 1) : [];
  if (first) {
    return accessList(jsAccess(what, first), rest);
  } else {
    return what;
  }
};

isAlreadyParametrized = function(ctx, constraint) {
  return !!ctx.classParamNameFor(constraint);
};

instanceDictFor = function(ctx, constraint) {
  var name, type, _j, _len1, _ref1, _ref2;
  _ref1 = (ctx.classNamed(constraint.className)).instances;
  for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
    _ref2 = _ref1[_j], name = _ref2.name, type = _ref2.type;
    if (toMatchTypes(type.type.types, constraint.types)) {
      return validIdentifier(name);
    }
  }
  throw new Error("no instance for " + (safePrintType(constraint)));
};

irFunction = function(_arg) {
  var body, name, params;
  name = _arg.name, params = _arg.params, body = _arg.body;
  return {
    ir: irFunctionTranslate,
    name: name,
    params: params,
    body: body
  };
};

irFunctionTranslate = function(ctx, _arg) {
  var body, name, params;
  name = _arg.name, params = _arg.params, body = _arg.body;
  return jsCall("" + params.length, [
    jsFunction({
      name: (name ? validIdentifier(name) : void 0),
      params: map(validIdentifier, params),
      body: translateIr(ctx, body)
    })
  ]);
};

irList = function(items) {
  return {
    ir: irListTranslate,
    items: items
  };
};

irListTranslate = function(ctx, _arg) {
  var items;
  items = _arg.items;
  return jsCall("Immutable.List.of", translateIr(ctx, items));
};

irMap = function(keys, elems) {
  return {
    ir: irMapTranslate,
    keys: keys,
    elems: elems
  };
};

irMapTranslate = function(ctx, _arg) {
  var elems, keys;
  keys = _arg.keys, elems = _arg.elems;
  return jsCall("Immutable.Map", [jsArray(map(jsArray, zip(translateIr(ctx, keys), translateIr(ctx, elems))))]);
};

irSet = function(items) {
  return {
    ir: irSetTranslate,
    items: items
  };
};

irSetTranslate = function(ctx, _arg) {
  var items;
  items = _arg.items;
  return jsCall("Immutable.Set.of", items);
};

irJsCompatible = function(type, expression) {
  return {
    ir: irJsCompatibleTranslate,
    type: type,
    expression: expression
  };
};

irJsCompatibleTranslate = function(ctx, _arg) {
  var expression, finalType, translated, type;
  type = _arg.type, expression = _arg.expression;
  finalType = substitute(ctx.substitution, type);
  translated = translateIr(ctx, expression);
  if (isCustomCollectionType(finalType)) {
    return jsCall(jsAccess(translated, 'toJS'), []);
  } else {
    return translated;
  }
};

isCustomCollectionType = function(_arg) {
  var helpContext, newVar, type;
  type = _arg.type;
  helpContext = new Context;
  newVar = function() {
    return helpContext.freshTypeVariable(star);
  };
  return (toMatchTypes(applyKindFn(listType, newVar()), type)) || (toMatchTypes(applyKindFn(hashmapType, newVar(), newVar()), type)) || (toMatchTypes(applyKindFn(hashsetType, newVar()), type));
};

isTypeAnnotation = function(expression) {
  return (isCall(expression)) && (':' === _symbol(_operator(expression)));
};

isComment = function(expression) {
  return (isCall(expression)) && ('#' === _symbol(_operator(expression)));
};

isCall = function(expression) {
  return (isForm(expression)) && (isEmptyForm(expression)) && expression[0].label === 'paren';
};

isRecord = function(expression) {
  var labels, values, _ref1;
  if (isTuple(expression)) {
    _ref1 = unzip(pairs(_terms(expression))), labels = _ref1[0], values = _ref1[1];
    return labels.length === values.length && (allMap(isLabel, labels));
  }
};

isSeq = function(expression) {
  return (isForm(expression)) && expression[0].label === 'brace';
};

isTuple = function(expression) {
  return (isForm(expression)) && expression[0].label === 'bracket';
};

isEmptyForm = function(form) {
  return (_terms(form)).length > 0;
};

isForm = function(expression) {
  return Array.isArray(expression);
};

isLabel = function(atom) {
  return /:$/.test(atom.symbol);
};

isCapital = function(atom) {
  return /[A-Z]/.test(atom.symbol);
};

isName = function(expression) {
  var _ref1;
  if (!expression) {
    throw new Error("Nothing passed to isName");
  }
  return (isAtom(expression)) && (((_ref1 = expression.symbol) === '~' || _ref1 === '/' || _ref1 === '//') || /[^~"'\/].*/.test(expression.symbol));
};

isAtom = function(expression) {
  return !(Array.isArray(expression));
};

_labeled = function(list) {
  return pairsLeft(isLabel, list);
};

pairsLeft = function(leftTest, list) {
  return listToPairsWith(list, function(item, next) {
    if (leftTest(item)) {
      return [item, (next && !leftTest(next) ? next : null)];
    } else {
      if (leftTest(item)) {
        return [item, null];
      } else {
        return [null, item];
      }
    }
  });
};

pairsRight = function(rightTest, list) {
  return pairsLeft((function(x) {
    return !rightTest(x);
  }), list);

  /*listToPairsWith list, (item, next) ->
    if next and rightTest next
      [(if not rightTest item then item else null), next]
    else
      if rightTest item
        [null, item]
      else
        [item, null]
   */
};

listToPairsWith = function(list, convertBy) {
  var i, result;
  return filter(_is, ((function() {
    var _results;
    i = 0;
    _results = [];
    while (i < list.length) {
      result = convertBy(list[i], list[i + 1]);
      if (result[0] && result[1]) {
        i++;
      }
      i++;
      _results.push(result);
    }
    return _results;
  })()));
};

pairs = function(list) {
  var el, i, _j, _len1, _results;
  _results = [];
  for (i = _j = 0, _len1 = list.length; _j < _len1; i = _j += 2) {
    el = list[i];
    _results.push([el, list[i + 1]]);
  }
  return _results;
};

tuplize = function(n, list) {
  var e, i, _j, _len1, _results;
  _results = [];
  for ((n > 0 ? (i = _j = 0, _len1 = list.length) : i = _j = list.length - 1); n > 0 ? _j < _len1 : _j >= 0; i = _j += n) {
    e = list[i];
    _results.push(list.slice(i, i + n));
  }
  return _results;
};

unzip = function(pairs) {
  return [map(_fst, pairs), map(_snd, pairs)];
};

zip = function(list1, list2) {
  return zipWith((function(a, b) {
    return [a, b];
  }), list1, list2);
};

zipWith = function(fn, list1, list2) {
  var el, i, _j, _len1, _results;
  _results = [];
  for (i = _j = 0, _len1 = list1.length; _j < _len1; i = ++_j) {
    el = list1[i];
    _results.push(fn(el, list2[i]));
  }
  return _results;
};

replicate = function(expression, newForm) {
  return newForm;
};

retrieve = function(expression, newForm) {
  expression.tea = newForm.tea;
  return expression.malformed = newForm.malformed;
};

filterAst = function(test, expression) {
  var term;
  return join(filter(test, [expression]), isForm(expression) ? concat((function() {
    var _j, _len1, _ref1, _results;
    _ref1 = _terms(expression);
    _results = [];
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      term = _ref1[_j];
      _results.push(filterAst(test, term));
    }
    return _results;
  })()) : []);
};

translateStatementsToJs = function(jsAstList) {
  return listOfLines(translateToJs(jsAstList));
};

translateToJs = function(jsAst) {
  return walkIr(jsAst, function(ast) {
    var args, name, node;
    args = {};
    for (name in ast) {
      node = ast[name];
      if (name !== 'js') {
        args[name] = node && translateToJs(node);
      }
    }
    return ast.js(args);
  });
};

walkIr = function(ast, cb) {
  var node, _j, _len1, _results;
  if (Array.isArray(ast)) {
    _results = [];
    for (_j = 0, _len1 = ast.length; _j < _len1; _j++) {
      node = ast[_j];
      _results.push(walkIr(node, cb));
    }
    return _results;
  } else if (ast.ir || ast.js) {
    return cb(ast);
  } else {
    return ast;
  }
};

printIr = function(ast) {
  return walkIr(ast, function(ast) {
    var args, name, node;
    args = {};
    for (name in ast) {
      node = ast[name];
      args[name] = node != null ? name === 'js' || name === 'ir' ? true : printIr(node) : void 0;
    }
    return args;
  });
};

jsAccess = function(lhs, name) {
  return {
    js: jsAccessTranslate,
    lhs: lhs,
    name: name
  };
};

jsAccessTranslate = function(_arg) {
  var lhs, name;
  lhs = _arg.lhs, name = _arg.name;
  if (/^\d/.test(name)) {
    return "" + lhs + "[" + name + "]";
  } else if ((validIdentifier(name)) !== name) {
    return "" + lhs + "['" + name + "']";
  } else {
    return "" + lhs + "." + name;
  }
};

jsArray = function(elems) {
  return {
    js: jsArrayTranslate,
    elems: elems
  };
};

jsArrayTranslate = function(_arg) {
  var elems;
  elems = _arg.elems;
  return "[" + (listOf(elems)) + "]";
};

jsAssign = function(lhs, rhs) {
  return {
    js: jsAssignTranslate,
    lhs: lhs,
    rhs: rhs
  };
};

jsAssignTranslate = function(_arg) {
  var lhs, rhs;
  lhs = _arg.lhs, rhs = _arg.rhs;
  return "(" + lhs + " = " + rhs + ")";
};

jsAssignStatement = function(lhs, rhs) {
  return {
    js: jsAssignStatementTranslate,
    lhs: lhs,
    rhs: rhs
  };
};

jsAssignStatementTranslate = function(_arg) {
  var lhs, rhs;
  lhs = _arg.lhs, rhs = _arg.rhs;
  return "" + lhs + " = " + rhs + ";";
};

jsBinary = function(op, lhs, rhs) {
  return {
    js: jsBinaryTranslate,
    op: op,
    lhs: lhs,
    rhs: rhs
  };
};

jsBinaryTranslate = function(_arg) {
  var lhs, op, rhs;
  op = _arg.op, lhs = _arg.lhs, rhs = _arg.rhs;
  return jsBinaryMultiTranslate({
    op: op,
    args: [lhs, rhs]
  });
};

jsBinaryMulti = function(op, args) {
  return {
    js: jsBinaryMultiTranslate,
    op: op,
    args: args
  };
};

jsBinaryMultiTranslate = function(_arg) {
  var args, op;
  op = _arg.op, args = _arg.args;
  return "(" + (args.join(" " + op + " ")) + ")";
};

jsCall = function(fun, args) {
  return {
    js: jsCallTranslate,
    fun: fun,
    args: args
  };
};

jsCallTranslate = function(_arg) {
  var args, fun;
  fun = _arg.fun, args = _arg.args;
  return "" + fun + "(" + (listOf(args)) + ")";
};

jsConditional = function(condCasePairs, elseCase) {
  return {
    js: jsConditionalTranslate,
    condCasePairs: condCasePairs,
    elseCase: elseCase
  };
};

jsConditionalTranslate = function(_arg) {
  var branch, cond, condCasePairs, control, elseCase, i;
  condCasePairs = _arg.condCasePairs, elseCase = _arg.elseCase;
  return (((function() {
    var _j, _len1, _ref1, _results;
    _results = [];
    for (i = _j = 0, _len1 = condCasePairs.length; _j < _len1; i = ++_j) {
      _ref1 = condCasePairs[i], cond = _ref1[0], branch = _ref1[1];
      control = i === 0 ? 'if' : ' else if';
      _results.push("" + control + " (" + cond + ") {\n  " + (listOfLines(branch)) + "\n}");
    }
    return _results;
  })()).join('')) + (" else {\n  " + elseCase + "\n}");
};

jsExprList = function(elems) {
  return {
    js: jsExprListTranslate,
    elems: elems
  };
};

jsExprListTranslate = function(_arg) {
  var elems;
  elems = _arg.elems;
  return "(" + (listOf(elems)) + ")";
};

jsFunction = function(_arg) {
  var body, name, params;
  name = _arg.name, params = _arg.params, body = _arg.body;
  if (!Array.isArray(body)) {
    throw new Error("body of jsFunction must be a list");
  }
  return {
    js: jsFunctionTranslate,
    name: name,
    params: params,
    body: body
  };
};

jsFunctionTranslate = function(_arg) {
  var body, name, params;
  name = _arg.name, params = _arg.params, body = _arg.body;
  return "function " + (name || '') + "(" + (listOf(params)) + "){" + (blockOfLines(body)) + "}";
};

jsMalformed = function(message) {
  return {
    js: jsMalformedTranslate,
    message: message
  };
};

jsMalformedTranslate = function(_arg) {
  var message;
  message = _arg.message;
  return message;
};

jsNew = function(classFun, args) {
  return {
    js: jsNewTranslate,
    classFun: classFun,
    args: args
  };
};

jsNewTranslate = function(_arg) {
  var args, classFun;
  classFun = _arg.classFun, args = _arg.args;
  return "new " + classFun + "(" + (listOf(args)) + ")";
};

jsNoop = function() {
  return {
    js: jsNoopTranslate
  };
};

jsNoopTranslate = function() {
  return "";
};

jsReturn = function(arg) {
  return {
    js: jsReturnTranslate,
    arg: arg
  };
};

jsReturnTranslate = function(_arg) {
  var arg;
  arg = _arg.arg;
  return "return " + arg + ";";
};

jsTernary = function(cond, thenExp, elseExp) {
  return {
    js: jsTernaryTranslate,
    cond: cond,
    thenExp: thenExp,
    elseExp: elseExp
  };
};

jsTernaryTranslate = function(_arg) {
  var cond, elseExp, thenExp;
  cond = _arg.cond, thenExp = _arg.thenExp, elseExp = _arg.elseExp;
  return "" + cond + " ? " + thenExp + " : " + elseExp;
};

jsUnary = function(op, arg) {
  return {
    js: jsUnaryTranslate,
    op: op,
    arg: arg
  };
};

jsUnaryTranslate = function(_arg) {
  var arg, op;
  op = _arg.op, arg = _arg.arg;
  return "" + op + arg;
};

jsVarDeclaration = function(name, rhs) {
  return {
    js: jsVarDeclarationTranslate,
    name: name,
    rhs: rhs
  };
};

jsVarDeclarationTranslate = function(_arg) {
  var name, rhs;
  name = _arg.name, rhs = _arg.rhs;
  return "var " + name + " = " + rhs + ";";
};

jsVarDeclarations = function(names) {
  return {
    js: jsVarDeclarationsTranslate,
    names: names
  };
};

jsVarDeclarationsTranslate = function(_arg) {
  var names;
  names = _arg.names;
  return "var " + (listOf(names)) + ";";
};

blockOfLines = function(lines) {
  if (lines.length === 0) {
    return '';
  } else {
    return '\n' + (listOfLines(lines)) + '\n';
  }
};

listOfLines = function(lines) {
  return lines.join('\n');
};

indentLines = function(indent, lines) {
  return blockOfLines(map((function(line) {
    return indent + line;
  }), filter(_notEmpty, lines)));
};

listOf = function(args) {
  return args.join(', ');
};

theme = {
  keyword: 'red',
  numerical: '#FEDF6B',
  "const": '#FEDF6B',
  typename: '#FEDF6B',
  typecons: '#67B3DD',
  label: '#9C49B6',
  string: '#FEDF6B',
  char: '#FEDF6B',
  paren: '#444',
  name: '#9EE062',
  recurse: '#67B3DD',
  param: '#FDA947',
  comment: 'grey',
  operator: '#67B3DD',
  normal: 'white'
};

colorize = function(color, string) {
  return "<span style=\"color: " + color + "\">" + string + "</span>";
};

labelRequires = function(ast) {
  return macro('require', ast, function(node, words) {
    var fun, list, module, req, _j, _len1, _ref1;
    req = words[0], module = words[1], list = words[2];
    module.label = 'symbol';
    _ref1 = inside(list);
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      fun = _ref1[_j];
      fun.label = 'symbol';
    }
    return node;
  });
};

labelComments = function(call) {
  var term, _j, _len1, _ref1, _results;
  _ref1 = _terms(call);
  _results = [];
  for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
    term = _ref1[_j];
    _results.push(term.label = 'comment');
  }
  return _results;
};

toHtml = function(highlighted) {
  return crawl(highlighted, function(word, symbol, parent) {
    return (word.ws || '') + colorize(theme[labelOf(word)], symbol);
  });
};

labelOf = function(word) {
  return word.label || 'normal';
};

collapse = function(nodes) {
  var collapsed, node, _j, _len1;
  collapsed = "";
  for (_j = 0, _len1 = nodes.length; _j < _len1; _j++) {
    node = nodes[_j];
    crawl(node, function(node) {
      return collapsed += node;
    });
  }
  return collapsed;
};

parentize = function(ast) {
  return walk(ast, function(node) {
    var subNode, _j, _len1, _results;
    _results = [];
    for (_j = 0, _len1 = node.length; _j < _len1; _j++) {
      subNode = node[_j];
      _results.push(subNode.parent = node);
    }
    return _results;
  });
};

walk = function(ast, cb) {
  var node, _j, _len1;
  if (Array.isArray(ast)) {
    cb(ast);
    for (_j = 0, _len1 = ast.length; _j < _len1; _j++) {
      node = ast[_j];
      walk(node, cb);
    }
  }
  return ast;
};

exportList = function(source) {
  var names, pattern, wheres, _j, _len1;
  wheres = whereList(inside(preCompileDefs(source)));
  names = [];
  for (_j = 0, _len1 = wheres.length; _j < _len1; _j++) {
    pattern = wheres[_j][0];
    if (pattern.symbol && pattern.symbol !== '_') {
      names.push(pattern.symbol);
    }
  }
  return names;
};

validIdentifier = function(name) {
  return (inSet(reservedInJs, name) ? "" + name + "_" : name === '.' ? "dot_" : name).replace(/\+/g, 'plus_').replace(/\-/g, '__').replace(/\*/g, 'times_').replace(/\//g, 'over_').replace(/\!/g, 'not_').replace(/\=/g, 'eq_').replace(/\</g, 'lt_').replace(/\>/g, 'gt_').replace(/\~/g, 'neg_').replace(/\^/g, 'pow_').replace(/\&/g, 'and_').replace(/\?/g, 'p_');
};

hoistWheres = function(hoistable, assigns) {
  var def, defined, hoisted, hoistedNames, missing, n, name, names, notHoisted, set, stillMissingDeps, stillMissingNames, where, _, _j, _len1;
  defined = addAllToSet(newSet(), (function() {
    var _j, _len1, _ref1, _results;
    _results = [];
    for (_j = 0, _len1 = assigns.length; _j < _len1; _j++) {
      _ref1 = assigns[_j], n = _ref1[0], _ = _ref1[1];
      _results.push(n);
    }
    return _results;
  })());
  hoistedNames = newSet();
  hoisted = [];
  notHoisted = [];
  for (_j = 0, _len1 = hoistable.length; _j < _len1; _j++) {
    where = hoistable[_j];
    missing = where.missing, names = where.names, def = where.def, set = where.set;
    stillMissingNames = addAllToSet(newSet(), (function() {
      var _k, _len2, _ref1, _results;
      _ref1 = setToArray(missing);
      _results = [];
      for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
        name = _ref1[_k];
        if (!inSet(defined, name)) {
          _results.push(name);
        }
      }
      return _results;
    })());
    stillMissingDeps = removeAllFromSet(cloneSet(set), setToArray(hoistedNames));
    if (stillMissingNames.size === 0 && stillMissingDeps.size === 0) {
      hoisted.push(def);
      addAllToSet(hoistedNames, names);
    } else {
      notHoisted.push({
        def: def,
        names: names,
        missing: stillMissingNames,
        set: stillMissingDeps
      });
    }
  }
  return [hoisted, notHoisted];
};

toJsString = function(symbol) {
  return "'" + symbol + "'";
};

compileVariableAssignment = function(_arg) {
  var from, to;
  to = _arg[0], from = _arg[1];
  return jsVarDeclaration(to, from);
};

constructCond = function(precs) {
  var cases, i, lastCond, preassigns, prec, pushCurrentCase, singleCase, translateCondPart, _j, _len1;
  if (precs.length === 0) {
    return {
      conds: 'true',
      preassigns: []
    };
  }
  lastCond = false;
  cases = [];
  singleCase = [];
  translateCondPart = function(_arg) {
    var cache, cond;
    cond = _arg.cond, cache = _arg.cache;
    if (cond) {
      return cond;
    } else {
      return jsAssign(cache[0], cache[1]);
    }
  };
  pushCurrentCase = function() {
    var condParts;
    condParts = map(translateCondPart, singleCase);
    cases.push(condParts.length === 1 ? condParts[0] : jsExprList(condParts));
    return singleCase = [];
  };
  for (i = _j = 0, _len1 = precs.length; _j < _len1; i = ++_j) {
    prec = precs[i];
    if (lastCond) {
      pushCurrentCase();
    }
    singleCase.push(prec);
    lastCond = prec.cond;
  }
  preassigns = lastCond ? (pushCurrentCase(), []) : map(_cache, singleCase);
  return {
    conds: jsBinaryMulti("&&", cases),
    preassigns: preassigns
  };
};

macros = {
  'if': function(cond, zen, elz) {
    return "(function(){if (" + cond + ") {\n  return " + zen + ";\n} else {\n  return " + elz + ";\n}}())";
  },
  'access': function(field, obj) {
    return "(" + obj + ")[" + field + "]";
  },
  'call': function() {
    var args, method, obj;
    method = arguments[0], obj = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    return "(" + (macros.access(method, obj)) + "(" + (args.join(', ')) + "))";
  },
  'new': function() {
    var args, clazz;
    clazz = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return "(new " + clazz + "(" + (args.join(', ')) + "))";
  }
};

expandBuiltings = function(mapping, cb) {
  var i, op, _j, _len1, _ref1, _results;
  _ref1 = mapping.from;
  _results = [];
  for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
    op = _ref1[i];
    _results.push(macros[op] = cb(mapping.to[i]));
  }
  return _results;
};

unaryFnMapping = {
  from: 'sqrt alert! not empty'.split(' '),
  to: 'Math.sqrt window.log ! $empty'.split(' ')
};

expandBuiltings(unaryFnMapping, function(to) {
  return function(x) {
    if (x) {
      return "" + to + "(" + x + ")";
    } else {
      return "function(__a){return " + to + "(__a);}";
    }
  };
});

binaryFnMapping = {
  from: [],
  to: []
};

expandBuiltings(binaryFnMapping, function(to) {
  return function(x, y) {
    if (x && y) {
      return "" + to + "(" + x + ", " + y + ")";
    } else if (x) {
      return "function(__b){return " + to + "(" + a + ", __b);}";
    } else {
      return "function(__a, __b){return " + to + "(__a, __b);}";
    }
  };
});

invertedBinaryFnMapping = {
  from: '^'.split(' '),
  to: 'Math.pow'.split(' ')
};

expandBuiltings(invertedBinaryFnMapping, function(to) {
  return function(x, y) {
    if (x && y) {
      return "" + to + "(" + y + ", " + x + ")";
    } else if (x) {
      return "function(__b){return " + to + "(__b, " + a + ");}";
    } else {
      return "function(__a, __b){return " + to + "(__b, __a);}";
    }
  };
});

binaryOpMapping = {
  from: '+ * = != and or'.split(' '),
  to: '+ * == != && ||'.split(' ')
};

expandBuiltings(binaryOpMapping, function(to) {
  return function(x, y) {
    if (x && y) {
      return "(" + x + " " + to + " " + y + ")";
    } else if (x) {
      return "function(__b){return " + x + " " + to + " __b;}";
    } else {
      return "function(__a, __b){return __a " + to + " __b;}";
    }
  };
});

invertedBinaryOpMapping = {
  from: '- / rem < > <= >='.split(' '),
  to: '- / % < > <= >='.split(' ')
};

expandBuiltings(invertedBinaryOpMapping, function(to) {
  return function(x, y) {
    if (x && y) {
      return "(" + y + " " + to + " " + x + ")";
    } else if (x) {
      return "function(__b){return __b " + to + " " + x + ";}";
    } else {
      return "function(__a, __b){return __b " + to + " __a;}";
    }
  };
});

binaryMathOpType = '(Fn Num Num Num)';

comparatorOpType = '(Fn a a Bool)';

builtInTypeNames = function() {
  return arrayToMap(map((function(_arg) {
    var kind, name;
    name = _arg.name, kind = _arg.kind;
    return [name, kind];
  }), [arrowType, listType, hashmapType, hashsetType, stringType, charType, boolType, numType]));
};

builtInDefinitions = function() {
  return newMapWith('True', {
    type: quantifyAll(toConstrained(boolType)),
    arity: []
  }, 'False', {
    type: quantifyAll(toConstrained(boolType)),
    arity: []
  }, '==', {
    type: quantifyAll(toConstrained(typeFn(atomicType('a', star), atomicType('a', star), boolType))),
    arity: ['x', 'y']
  });
};

desiplifyTypeAndArity = function(simple) {
  var args, arity, i, type;
  type = parseUnConstrainedType(simple);
  args = collectArgs(type.type.type);
  arity = Array.isArray(args) ? args.length : 0;
  return {
    type: type,
    arity: (function() {
      var _j, _ref1, _results;
      _results = [];
      for (i = _j = 0, _ref1 = arity - 2; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
        _results.push("a" + i);
      }
      return _results;
    })()
  };
};

parseUnConstrainedType = function(string) {
  return quantifyAll(toConstrained(typeCompile(astize(tokenize(string)))));
};

desiplifyType = function(simple) {
  if (Array.isArray(simple)) {
    return typeFn.apply(null, map(desiplifyType, simple));
  } else if (/^[A-Z]/.test(simple)) {
    return typeConstant(simple);
  } else {
    return new TypeVariable(simple, star);
  }
};

newSet = newMap = function() {
  return {
    size: 0,
    values: {}
  };
};

addToSet = function(set, key) {
  return addToMap(set, key, true);
};

addToMap = function(set, key, value) {
  if (set.values[key]) {
    return;
  }
  set.size++;
  set.values[key] = value;
  return set;
};

replaceInMap = function(map, key, value) {
  return map.values[key] = value;
};

replaceOrAddToMap = function(map, key, value) {
  if (!map.values[key]) {
    map.size++;
  }
  map.values[key] = value;
  return map;
};

removeFromSet = removeFromMap = function(set, key) {
  if (set.values[key] == null) {
    return;
  }
  set.size -= 1;
  return delete set.values[key];
};

addAllToSet = function(set, array) {
  var v, _j, _len1;
  for (_j = 0, _len1 = array.length; _j < _len1; _j++) {
    v = array[_j];
    addToSet(set, v);
  }
  return set;
};

removeAllFromSet = function(set, array) {
  var v, _j, _len1;
  for (_j = 0, _len1 = array.length; _j < _len1; _j++) {
    v = array[_j];
    removeFromSet(set, v);
  }
  return set;
};

keysOfMap = setToArray = function(set) {
  var key, _results;
  _results = [];
  for (key in set.values) {
    _results.push(key);
  }
  return _results;
};

mapToArray = function(map) {
  var key, val, _ref1, _results;
  _ref1 = map.values;
  _results = [];
  for (key in _ref1) {
    val = _ref1[key];
    _results.push(val);
  }
  return _results;
};

mapToArrayVia = function(fn, map) {
  var key, val, _ref1, _results;
  _ref1 = map.values;
  _results = [];
  for (key in _ref1) {
    val = _ref1[key];
    _results.push(fn(key, val));
  }
  return _results;
};

cloneSet = cloneMap = function(set) {
  var clone, key, val, _ref1;
  clone = newSet();
  _ref1 = set.values;
  for (key in _ref1) {
    val = _ref1[key];
    addToMap(clone, key, val);
  }
  return clone;
};

lookupInMap = inSet = function(set, name) {
  return set.values[name];
};

isSetEmpty = isMapEmpty = function(set) {
  return set.size === 0;
};

mapSet = mapMap = function(fn, set) {
  var initialized, key, val, _ref1;
  initialized = newMap();
  _ref1 = set.values;
  for (key in _ref1) {
    val = _ref1[key];
    addToMap(initialized, key, fn(val));
  }
  return initialized;
};

filterSet = filterMap = function(fn, set) {
  var initialized, key, val, _ref1;
  initialized = newMap();
  _ref1 = set.values;
  for (key in _ref1) {
    val = _ref1[key];
    if (fn(key)) {
      addToMap(initialized, key, val);
    }
  }
  return initialized;
};

reduceSet = function(fn, def, set) {
  return (setToArray(set)).reduce(function(prev, curr) {
    return fn(curr, prev);
  }, def);
};

newSetWith = function() {
  var args, initialized, k, _j, _len1;
  args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  initialized = newSet();
  for (_j = 0, _len1 = args.length; _j < _len1; _j++) {
    k = args[_j];
    addToSet(initialized, k);
  }
  return initialized;
};

newMapWith = function() {
  var args, i, initialized, k, _j, _len1;
  args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  initialized = newMap();
  for (i = _j = 0, _len1 = args.length; _j < _len1; i = _j += 2) {
    k = args[i];
    addToMap(initialized, k, args[i + 1]);
  }
  return initialized;
};

newMapKeysVals = function(keys, vals) {
  var i, initialized, item, _j, _len1;
  initialized = newMap();
  for (i = _j = 0, _len1 = vals.length; _j < _len1; i = ++_j) {
    item = vals[i];
    addToMap(initialized, keys[i], item);
  }
  return initialized;
};

concatSets = concatMaps = function() {
  var concated, k, m, maps, v, _j, _len1, _ref1;
  maps = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  concated = newMap();
  for (_j = 0, _len1 = maps.length; _j < _len1; _j++) {
    m = maps[_j];
    _ref1 = m.values;
    for (k in _ref1) {
      v = _ref1[k];
      addToMap(concated, k, v);
    }
  }
  return concated;
};

concatConcatMaps = function(maps) {
  var concated, k, list, m, v, _j, _len1, _ref1;
  concated = newMap();
  for (_j = 0, _len1 = maps.length; _j < _len1; _j++) {
    m = maps[_j];
    _ref1 = m.values;
    for (k in _ref1) {
      v = _ref1[k];
      if (list = lookupInMap(concated, k)) {
        list.push(v);
      } else {
        addToMap(concated, k, [v]);
      }
    }
  }
  return concated;
};

subtractSets = subtractMaps = function(from, what) {
  var k, subtracted, v, _ref1;
  subtracted = newMap();
  _ref1 = from.values;
  for (k in _ref1) {
    v = _ref1[k];
    if (!(k in what.values)) {
      addToMap(subtracted, k, v);
    }
  }
  return subtracted;
};

arrayToSet = function(array) {
  return addAllToSet(newSet(), array);
};

arrayToMap = function(pairs) {
  var created, key, value, _j, _len1, _ref1;
  created = newMap();
  for (_j = 0, _len1 = pairs.length; _j < _len1; _j++) {
    _ref1 = pairs[_j], key = _ref1[0], value = _ref1[1];
    addToMap(created, key, value);
  }
  return created;
};

objectToMap = function(object) {
  var created, key, value;
  created = newMap();
  for (key in object) {
    value = object[key];
    addToMap(created, key, value);
  }
  return created;
};

values = function(map) {
  return map.values;
};

doIntersect = function(setA, setB) {
  return (subtractSets(setA, setB)).size !== setA.size;
};

isSubset = function(superSet, subSet) {
  return (subtractSets(subSet, superSet)).size === 0;
};

intersectRight = function(mapA, mapB) {
  var intersection, k, v, _ref1;
  intersection = newMap();
  _ref1 = mapB.values;
  for (k in _ref1) {
    v = _ref1[k];
    if (k in mapA.values) {
      addToMap(intersection, k, v);
    }
  }
  return intersection;
};

nestedAddToMap = function(map, keys, value) {
  var finalKey, key, nestedKeys, _j, _k, _len1;
  nestedKeys = 2 <= keys.length ? __slice.call(keys, 0, _j = keys.length - 1) : (_j = 0, []), finalKey = keys[_j++];
  for (_k = 0, _len1 = nestedKeys.length; _k < _len1; _k++) {
    key = nestedKeys[_k];
    map = lookupInMap(map, key);
    if (!map) {
      map = addToMap(map, key, newMap());
    }
  }
  return addToMap(map, finalKey, value);
};

nestedLookupInMap = function(map, keys) {
  var key, _j, _len1;
  for (_j = 0, _len1 = keys.length; _j < _len1; _j++) {
    key = keys[_j];
    if ((map != null ? map.size : void 0) == null) {
      return null;
    }
    map = lookupInMap(map, key);
  }
  return map;
};

unify = function(ctx, t1, t2) {
  var sub;
  if (!(ctx instanceof Context && t1 && t2)) {
    throw new Error("invalid args to unify");
  }
  sub = ctx.substitution;
  return ctx.extendSubstitution(mostGeneralUnifier(substitute(sub, t1), substitute(sub, t2)));
};

mostGeneralUnifier = function(t1, t2) {
  var s1, s2;
  if (t1 instanceof TypeVariable) {
    return bindVariable(t1, t2);
  } else if (t2 instanceof TypeVariable) {
    return bindVariable(t2, t1);
  } else if (t1 instanceof TypeConstr && t2 instanceof TypeConstr && t1.name === t2.name) {
    return emptySubstitution();
  } else if (t1 instanceof TypeApp && t2 instanceof TypeApp) {
    s1 = mostGeneralUnifier(t1.op, t2.op);
    s2 = mostGeneralUnifier(substitute(s1, t1.arg), substitute(s1, t2.arg));
    return joinSubs(s1, s2);
  } else if (t1 instanceof Types && t2 instanceof Types) {
    if (_notEmpty(t1.types)) {
      s1 = mostGeneralUnifier(t1.types[0], t2.types[0]);
      s2 = mostGeneralUnifier(new Types(t1.types.slice(1)), new Types(t2.types.slice(1)));
      return joinSubs(s1, s2);
    } else {
      return emptySubstitution();
    }
  } else {
    return unifyFail(t1, t2);
  }
};

unifyFail = function(t1, t2) {
  return substituionFail("could not unify " + (safePrintType(t1)) + ", " + (safePrintType(t2)));
};

bindVariable = function(variable, type) {
  if (type instanceof TypeVariable && variable.name === type.name) {
    return emptySubstitution();
  } else if (inSet(findFree(type), variable.name)) {
    return substituionFail("occurs check failed for " + variable.name);
  } else if (!kindsEq(kind(variable), kind(type))) {
    return substituionFail("kinds don't match for " + variable.name + " and " + (safePrintType(type)));
  } else {
    return newSubstitution(variable.name, type);
  }
};

toMatchTypes = function(t1, t2) {
  var substitution;
  substitution = matchType(t1, t2);
  if (_notEmpty(substitution.fails)) {
    return null;
  } else {
    return substitution;
  }
};

matchType = function(t1, t2) {
  var s1, s2, s3;
  if (t1 instanceof TypeVariable && kindsEq(kind(t1), kind(t2))) {
    return newSubstitution(t1.name, t2);
  } else if (t1 instanceof TypeConstr && t2 instanceof TypeConstr && t1.name === t2.name) {
    return emptySubstitution();
  } else if (t1 instanceof TypeApp && t2 instanceof TypeApp) {
    s1 = matchType(t1.op, t2.op);
    s2 = matchType(t1.arg, t2.arg);
    s3 = mergeSubs(s1, s2);
    return s3 || unifyFail(t1, t2);
  } else if (t1 instanceof Types && t2 instanceof Types) {
    if (_notEmpty(t1.types)) {
      s1 = matchType(t1.types[0], t2.types[0]);
      s2 = matchType(new Types(t1.types.slice(1)), new Types(t2.types.slice(1)));
      s3 = mergeSubs(s1, s2);
      return s3 || unifyFail(t1, t2);
    } else {
      return emptySubstitution();
    }
  } else {
    return unifyFail(t1, t2);
  }
};

joinSubs = function(s1, s2) {
  return subUnion(s1, mapSub((function(type) {
    return substitute(s1, type);
  }), s2));
};

mergeSubs = function(s1, s2) {
  var agree;
  agree = function(varName) {
    var variable;
    variable = new TypeVariable(varName, star);
    return typeEq(substitute(s1, variable), substitute(s2, variable));
  };
  if (allMap(agree, subIntersection(s1, s2))) {
    return subUnion(s1, s2);
  } else {
    return null;
  }
};

mapSub = function(fn, sub) {
  var mapped, name, v, _j, _ref1, _ref2;
  mapped = emptySubstitution();
  mapped.start = subStart(sub);
  mapped.fails = sub.fails;
  for (name = _j = _ref1 = subStart(sub), _ref2 = subLimit(sub); _j < _ref2; name = _j += 1) {
    if (v = inSub(sub, name)) {
      mapped.vars[name] = fn(v);
    }
  }
  return mapped;
};

subIntersection = function(subA, subB) {
  var name, _j, _ref1, _ref2, _results;
  _results = [];
  for (name = _j = _ref1 = subStart(subB), _ref2 = subLimit(subB); _j < _ref2; name = _j += 1) {
    if ((inSub(subB, name)) && (inSub(subA, name))) {
      _results.push(name);
    }
  }
  return _results;
};

subUnion = function(subA, subB) {
  var name, start, type, union, _j, _ref1;
  union = emptySubstitution();
  start = Math.min(subStart(subA), subStart(subB));
  union.start = start;
  for (name = _j = start, _ref1 = Math.max(subLimit(subA), subLimit(subB)); _j < _ref1; name = _j += 1) {
    type = (inSub(subA, name)) || (inSub(subB, name));
    if (type) {
      union.vars[name] = type;
    }
  }
  union.fails = [].concat(subA.fails, subB.fails);
  return union;
};

newSubstitution = function(name, type) {
  var sub;
  sub = emptySubstitution();
  sub.vars[name] = type;
  sub.start = name;
  return sub;
};

substituionFail = function(failure) {
  var sub;
  sub = emptySubstitution();
  sub.fails.push(failure);
  return sub;
};

subLimit = function(sub) {
  return sub.vars.length;
};

subStart = function(sub) {
  return sub.start;
};

inSub = function(sub, name) {
  return sub.vars[name];
};

emptySubstitution = function() {
  return {
    start: Infinity,
    fails: [],
    vars: []
  };
};

substitute = function(substitution, type) {
  if (type.TypeVariable && substitution.vars) {
    return (inSub(substitution, type.name)) || type;
  } else if (type.QuantifiedVar) {
    return substitution[type["var"]] || type;
  } else if (type.TypeApp) {
    return new TypeApp(substitute(substitution, type.op), substitute(substitution, type.arg));
  } else if (type.ForAll) {
    return new ForAll(type.kinds, substitute(substitution, type.type));
  } else if (type.Constrained) {
    return new Constrained(substituteList(substitution, type.constraints), substitute(substitution, type.type));
  } else if (type.ClassConstraint) {
    return new ClassConstraint(type.className, substitute(substitution, type.types));
  } else if (type.Types) {
    return new Types(substituteList(substitution, type.types));
  } else {
    return type;
  }
};

substituteList = function(substitution, list) {
  return map((function(t) {
    return substitute(substitution, t);
  }), list);
};

mapToSubstitution = function(map) {
  return {
    vars: map.values
  };
};

findFree = function(type) {
  if (type instanceof TypeVariable) {
    return newMapWith(type.name, type.kind);
  } else if (type instanceof TypeApp) {
    return concatMaps(findFree(type.op), findFree(type.arg));
  } else if (type instanceof Constrained) {
    return concatMaps(findFreeInList(type.constraints), findFree(type.type));
  } else if (type instanceof ClassConstraint) {
    return findFree(type.types);
  } else if (type instanceof Types) {
    return findFreeInList(type.types);
  } else {
    return newMap();
  }
};

findFreeInList = function(list) {
  return concatMaps.apply(null, map(findFree, list));
};

freshInstance = function(ctx, type) {
  var freshes;
  if (!(type instanceof ForAll)) {
    throw new Error("not a forall in freshInstance " + (safePrintType(type)));
  }
  freshes = map((function(kind) {
    return ctx.freshTypeVariable(kind);
  }), type.kinds);
  return (substitute(freshes, type)).type;
};

freshName = function(nameIndex) {
  return nameIndex;
};

isNormalizedConstraint = function(constraint) {
  return all(map(isNormalizedConstraintArgument, constraint.types.types));
};

isNormalizedConstraintArgument = function(type) {
  if (type instanceof TypeVariable) {
    return true;
  } else if (type instanceof TypeConstr) {
    return false;
  } else if (type instanceof TypeApp) {
    return isNormalizedConstraintArgument(type.op.type);
  }
};

typeEq = function(a, b) {
  if (a instanceof TypeVariable && b instanceof TypeVariable || a instanceof TypeConstr && b instanceof TypeConstr) {
    return a.name === b.name;
  } else if (a instanceof QuantifiedVar && b instanceof QuantifiedVar) {
    return a["var"] === b["var"];
  } else if (a instanceof TypeApp && b instanceof TypeApp) {
    return (typeEq(a.op, b.op)) && (typeEq(a.arg, b.arg));
  } else if (a instanceof ForAll && b instanceof ForAll) {
    return typeEq(a.type, b.type);
  } else if (a instanceof Constrained && b instanceof Constrained) {
    return (all(zipWith(typeEq, a.constraints, b.constraints))) && (typeEq(a.type, b.type));
  } else if (a instanceof ClassConstraint && b instanceof ClassConstraint) {
    return a.className === b.className && (all(zipWith(typeEq, a.types, b.types)));
  } else {
    return false;
  }
};

typeConstant = function(name) {
  return new TypeConstr(name, star);
};

atomicType = function(name, kind) {
  if (/^[A-Z]/.test(name)) {
    return new TypeConstr(name, kind);
  } else {
    return new TypeVariable(name, kind);
  }
};

tupleType = function(arity) {
  return new TypeConstr("[" + arity + "]", kindFn(arity));
};

tupleOfTypes = function(types) {
  return new Constrained(concatMap(_constraints, types), applyKindFn.apply(null, [tupleType(types.length)].concat(__slice.call(map(_type, types)))));
};

_constraints = function(type) {
  return type.constraints;
};

kindFn = function(arity) {
  if (arity === 0) {
    return star;
  } else {
    return new KindFn(star, kindFn(arity - 1));
  }
};

kindFnOfArgs = function() {
  var arg, args;
  arg = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
  if (!arg) {
    return star;
  } else {
    return new KindFn(arg, kindFnOfArgs.apply(null, args));
  }
};

typeFn = function() {
  var args, from, to;
  from = arguments[0], to = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
  if (args.length === 0) {
    if (!to) {
      return from;
    } else {
      return new TypeApp(new TypeApp(arrowType, from), to);
    }
  } else {
    return typeFn(from, typeFn.apply(null, [to].concat(__slice.call(args))));
  }
};

applyKindFn = function() {
  var arg, args, fn;
  fn = arguments[0], arg = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
  if (!arg) {
    return fn;
  } else if (args.length === 0) {
    return new TypeApp(fn, arg);
  } else {
    return applyKindFn.apply(null, [applyKindFn(fn, arg)].concat(__slice.call(args)));
  }
};

isConstructor = function(type) {
  return type instanceof TypeApp;
};

kind = function(type) {
  if (type.kind) {
    return type.kind;
  } else if (type instanceof TypeApp) {
    return (kind(type.op)).to;
  } else {
    throw new Error("Invalid type in kind");
  }
};

kindsEq = function(k1, k2) {
  return k1 === k2 || k1.from && k2.from && (kindsEq(k1.from, k2.from)) && (kindsEq(k1.to, k2.to));
};

KindFn = (function() {
  function KindFn(from, to) {
    this.from = from;
    this.to = to;
  }

  return KindFn;

})();

TypeVariable = (function() {
  function TypeVariable(name, kind) {
    this.name = name;
    this.kind = kind;
  }

  TypeVariable.prototype.TypeVariable = true;

  return TypeVariable;

})();

TypeConstr = (function() {
  function TypeConstr(name, kind) {
    this.name = name;
    this.kind = kind;
  }

  TypeConstr.prototype.TypeConstr = true;

  return TypeConstr;

})();

TypeApp = (function() {
  function TypeApp(op, arg) {
    this.op = op;
    this.arg = arg;
  }

  TypeApp.prototype.TypeApp = true;

  return TypeApp;

})();

QuantifiedVar = (function() {
  function QuantifiedVar(_var) {
    this["var"] = _var;
  }

  QuantifiedVar.prototype.QuantifiedVar = true;

  return QuantifiedVar;

})();

ForAll = (function() {
  function ForAll(kinds, type) {
    this.kinds = kinds;
    this.type = type;
  }

  ForAll.prototype.ForAll = true;

  return ForAll;

})();

TempType = (function() {
  function TempType(type) {
    this.type = type;
  }

  TempType.prototype.TempType = true;

  return TempType;

})();

Types = (function() {
  function Types(types) {
    this.types = types;
  }

  Types.prototype.Types = true;

  return Types;

})();

Constrained = (function() {
  function Constrained(constraints, type) {
    this.constraints = constraints;
    this.type = type;
  }

  Constrained.prototype.Constrained = true;

  return Constrained;

})();

ClassConstraint = (function() {
  function ClassConstraint(className, types) {
    this.className = className;
    this.types = types;
  }

  ClassConstraint.prototype.ClassConstraint = true;

  return ClassConstraint;

})();

addConstraints = function(_arg, addedConstraints) {
  var constraints, type;
  constraints = _arg.constraints, type = _arg.type;
  return new Constrained(join(constraints, addedConstraints), type);
};

toConstrained = function(type) {
  return new Constrained([], type);
};

toForAll = function(type) {
  return new ForAll([], type);
};

quantifyAll = function(type) {
  return quantify(findFree(type), type);
};

quantify = function(vars, type) {
  var kinds, polymorphicVars, quantifiedVars, varIndex;
  polymorphicVars = filterMap((function(name) {
    return inSet(vars, name);
  }), findFree(type));
  kinds = mapToArray(polymorphicVars);
  varIndex = 0;
  quantifiedVars = mapToSubstitution(mapMap((function() {
    return new QuantifiedVar(varIndex++);
  }), polymorphicVars));
  return new ForAll(kinds, substitute(quantifiedVars, type));
};

star = '*';

arrowType = new TypeConstr('Fn', kindFn(2));

listType = new TypeConstr('List', kindFn(1));

hashmapType = new TypeConstr('Map', kindFn(2));

hashsetType = new TypeConstr('Set', kindFn(1));

stringType = typeConstant('String');

charType = typeConstant('Char');

boolType = typeConstant('Bool');

numType = typeConstant('Num');

safePrintType = function(type) {
  var e;
  try {
    return printType(type);
  } catch (_error) {
    e = _error;
    return "" + type;
  }
};

printType = function(type) {
  if (type instanceof TypeVariable) {
    return "" + type.name;
  } else if (type instanceof QuantifiedVar) {
    return "" + type["var"];
  } else if (type instanceof TypeConstr) {
    return "" + type.name;
  } else if (type instanceof TypeApp) {
    return flattenType(collectArgs(type));
  } else if (type instanceof ForAll) {
    return "( " + (printType(type.type)) + ")";
  } else if (type instanceof ClassConstraint) {
    return "(" + type.className + " " + ((map(printType, type.types.types)).join(' ')) + ")";
  } else if (type instanceof Constrained) {
    return "(: " + ((map(printType, join([type.type], type.constraints))).join(' ')) + ")";
  } else if (type instanceof TempType) {
    return "(. " + (printType(type.type)) + ")";
  } else if (Array.isArray(type)) {
    return "\"" + (listOf(type)) + "\"";
  } else if (type === void 0) {
    return "undefined";
  } else {
    throw new Error("Unrecognized type in printType");
  }
};

collectArgs = function(type) {
  var arg, op;
  if (type instanceof TypeApp) {
    op = collectArgs(type.op);
    arg = collectArgs(type.arg);
    if ((Array.isArray(op)) && (Array.isArray(arg)) && op[0] === 'Fn' && arg[0] === 'Fn') {
      return join(op, arg.slice(1));
    } else {
      return join((Array.isArray(op) ? op : [op]), [Array.isArray(arg) ? flattenType(arg) : arg]);
    }
  } else {
    return printType(type);
  }
};

flattenType = function(types) {
  if (types[0].match(/^\[\d+\]$/)) {
    return "[" + (types.slice(1).join(' ')) + "]";
  } else {
    return "(" + (types.join(' ')) + ")";
  }
};

library = "var $listize = function (list) {\n  if (list.length === 0) {\n   return {length: 0};\n  }\n  return and_(list[0], $listize(list.slice(1)));\n};\n\nvar and_ = function (x, xs) {\n  if (typeof xs === \"undefined\" || xs === null) {\n    throw new Error('Second argument to & must be a sequence');\n  }\n  if (Immutable.List.isList(xs)) {\n    return xs.unshift(x);\n  }\n  if (Immutable.Set.isSet(xs)) {\n    return xs.add(x);\n  }\n  if (typeof xs == 'string' || xs instanceof String) {\n    if (xs === '' && !(typeof x == 'string' || x instanceof String)) {\n      return [x];\n    } else {\n      return x + xs;\n    }\n  }\n  if (xs.unshift) {\n    return [x].concat(xs);\n  }// cases for other sequences\n  return {\n    head: x,\n    tail: xs\n  };\n};\n\nvar seq_size = function (xs) {\n  if (typeof xs === \"undefined\" || xs === null) {\n    throw new Error('Pattern matching on size of undefined');\n  }\n  if (xs.size !== null) {\n    return xs.size;\n  }\n  if (xs.length !== null) {\n    return xs.length;\n  }\n  return 1 + seq_size(xs.tail);\n};\n\nvar seq_at = function (i, xs) {\n  if (typeof xs === \"undefined\" || xs === null) {\n    throw new Error('Pattern matching required sequence got undefined');\n  }\n  if (Immutable.List.isList(xs)) {\n    if (i >= xs.size) {\n      throw new Error('Pattern matching required a list of size at least ' + (i + 1));\n    }\n    return xs.get(i);\n  }\n  if (xs.length !== null) {\n    if (i >= xs.length) {\n      throw new Error('Pattern matching required a list of size at least ' + (i + 1));\n    }\n    return xs[i];\n  }\n  if (i === 0) {\n    return xs.head;\n  }\n  return seq_at(i - 1, xs.tail);\n};\n\nvar seq_splat = function (from, leave, xs) {\n  if (xs.slice) {\n    return xs.slice(from, (xs.size || xs.length) - leave);\n  }\n  return $listSlice(from, seq_size(xs) - leave - from, xs);\n};\n\n// temporary, will be replaced by typed 0-argument function\nvar $empty = function (xs) {\n  if (typeof xs === \"undefined\" || xs === null) {\n    throw new Error('Empty needs a sequence');\n  }\n  if (typeof xs == 'string' || xs instanceof String) {\n    return \"\";\n  }\n  if (xs.unshift) {\n    return [];\n  }\n  if ('length' in xs) {\n    return $listize([]);\n  } // cases for other sequences\n  return {};\n};\n\nvar $listSlice = function (from, n, xs) {\n  if (n === 0) {\n    return $listize([]);\n  }\n  if (from === 0) {\n    return and_(xs.head, $listSlice(from, n - 1, xs.tail));\n  }\n  return $listSlice(from - 1, n, xs.tail);\n};\n\nvar show__list = function (x) {\n  var t = [];\n  while (x.length !== 0) {\n    t.push(x.head);\n    x = x.tail;\n  }\n  return t;\n};\n\nvar from__nullable = function (jsValue) {\n  if (typeof jsValue === \"undefined\" || jsValue === null) {\n    return {';none': true};\n  } else {\n    return {':just': [jsValue]};\n  }\n};" + ((function() {
  var _j, _results;
  _results = [];
  for (i = _j = 1; _j <= 9; i = ++_j) {
    varNames = "abcdefghi".split('');
    first = function(j) {
      return varNames.slice(0, j).join(', ');
    };
    _results.push("var _" + i + " = function (fn, " + (first(i)) + ") {\n  if (fn._ === " + i + " || fn.length === " + i + ") {\n    return fn(" + (first(i)) + ");\n  } else if (fn._ > " + i + " || fn.length > " + i + ") {\n    return function (" + varNames[i] + ") {\n      return _" + (i + 1) + "(fn, " + (first(i + 1)) + ");\n    };\n  } else {\n    return _1(" + (i === 1 ? "fn()" : "_" + (i - 1) + "(fn, " + (first(i - 1)) + ")") + ", " + varNames[i - 1] + ");\n  }\n};");
  }
  return _results;
})()).join('\n\n') + ((function() {
  var _j, _results;
  _results = [];
  for (i = _j = 0; _j <= 9; i = ++_j) {
    _results.push("var " + i + " = function (fn) {\n  fn._ = " + i + ";\n  return fn;\n};");
  }
  return _results;
})()).join('\n\n') + ";";

eval(library);

immutable = "/**\n *  Copyright (c) 2014-2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n *\n * I removed the loader code for nodejs and amd because it was clashing with require js for now\n * I also changed context to window, to make sure it registers when evaling\n */\n!function(t,e){window.Immutable=e()}(this,function(){\"use strict\";function t(t,e){e&&(t.prototype=Object.create(e.prototype)),t.prototype.constructor=t}function e(t){return t.value=!1,t}function r(t){t&&(t.value=!0)}function n(){}function i(t,e){e=e||0;for(var r=Math.max(0,t.length-e),n=Array(r),i=0;r>i;i++)n[i]=t[i+e];return n}function o(t){return void 0===t.size&&(t.size=t.__iterate(s)),t.size}function u(t,e){return e>=0?+e:o(t)+ +e}function s(){return!0}function a(t,e,r){return(0===t||void 0!==r&&-r>=t)&&(void 0===e||void 0!==r&&e>=r)}function h(t,e){return c(t,e,0)}function f(t,e){return c(t,e,e)}function c(t,e,r){return void 0===t?r:0>t?Math.max(0,e+t):void 0===e?t:Math.min(e,t)}function _(t){return y(t)?t:O(t)}function p(t){return d(t)?t:x(t)}function v(t){return m(t)?t:k(t)}function l(t){return y(t)&&!g(t)?t:A(t)}function y(t){return!(!t||!t[pn])}function d(t){return!(!t||!t[vn])}function m(t){return!(!t||!t[ln])}function g(t){return d(t)||m(t)}function w(t){return!(!t||!t[yn])}function S(t){this.next=t}function z(t,e,r,n){var i=0===t?e:1===t?r:[e,r];return n?n.value=i:n={value:i,done:!1},n}function I(){return{value:void 0,done:!0}}function b(t){return!!M(t)}function q(t){return t&&\"function\"==typeof t.next}function D(t){var e=M(t);return e&&e.call(t)}function M(t){var e=t&&(wn&&t[wn]||t[Sn]);return\"function\"==typeof e?e:void 0}function E(t){return t&&\"number\"==typeof t.length}function O(t){return null===t||void 0===t?T():y(t)?t.toSeq():C(t)}function x(t){return null===t||void 0===t?T().toKeyedSeq():y(t)?d(t)?t.toSeq():t.fromEntrySeq():W(t)}function k(t){return null===t||void 0===t?T():y(t)?d(t)?t.entrySeq():t.toIndexedSeq():B(t)}function A(t){return(null===t||void 0===t?T():y(t)?d(t)?t.entrySeq():t:B(t)).toSetSeq()}function j(t){this._array=t,this.size=t.length}function R(t){var e=Object.keys(t);this._object=t,this._keys=e,this.size=e.length}function U(t){this._iterable=t,this.size=t.length||t.size\n}function K(t){this._iterator=t,this._iteratorCache=[]}function L(t){return!(!t||!t[In])}function T(){return bn||(bn=new j([]))}function W(t){var e=Array.isArray(t)?new j(t).fromEntrySeq():q(t)?new K(t).fromEntrySeq():b(t)?new U(t).fromEntrySeq():\"object\"==typeof t?new R(t):void 0;if(!e)throw new TypeError(\"Expected Array or iterable object of [k, v] entries, or keyed object: \"+t);return e}function B(t){var e=J(t);if(!e)throw new TypeError(\"Expected Array or iterable object of values: \"+t);return e}function C(t){var e=J(t)||\"object\"==typeof t&&new R(t);if(!e)throw new TypeError(\"Expected Array or iterable object of values, or keyed object: \"+t);return e}function J(t){return E(t)?new j(t):q(t)?new K(t):b(t)?new U(t):void 0}function P(t,e,r,n){var i=t._cache;if(i){for(var o=i.length-1,u=0;o>=u;u++){var s=i[r?o-u:u];if(e(s[1],n?s[0]:u,t)===!1)return u+1}return u}return t.__iterateUncached(e,r)}function H(t,e,r,n){var i=t._cache;if(i){var o=i.length-1,u=0;return new S(function(){var t=i[r?o-u:u];return u++>o?I():z(e,n?t[0]:u-1,t[1])})}return t.__iteratorUncached(e,r)}function N(){throw TypeError(\"Abstract\")}function V(){}function Y(){}function Q(){}function X(t,e){return t===e||t!==t&&e!==e?!0:t&&e?(\"function\"==typeof t.valueOf&&\"function\"==typeof e.valueOf&&(t=t.valueOf(),e=e.valueOf()),\"function\"==typeof t.equals&&\"function\"==typeof e.equals?t.equals(e):t===e||t!==t&&e!==e):!1}function F(t,e){return e?G(e,t,\"\",{\"\":t}):Z(t)}function G(t,e,r,n){return Array.isArray(e)?t.call(n,r,k(e).map(function(r,n){return G(t,r,n,e)})):$(e)?t.call(n,r,x(e).map(function(r,n){return G(t,r,n,e)})):e}function Z(t){return Array.isArray(t)?k(t).map(Z).toList():$(t)?x(t).map(Z).toMap():t}function $(t){return t&&(t.constructor===Object||void 0===t.constructor)}function te(t){return t>>>1&1073741824|3221225471&t}function ee(t){if(t===!1||null===t||void 0===t)return 0;if(\"function\"==typeof t.valueOf&&(t=t.valueOf(),t===!1||null===t||void 0===t))return 0;if(t===!0)return 1;var e=typeof t;if(\"number\"===e){var r=0|t;for(r!==t&&(r^=4294967295*t);t>4294967295;)t/=4294967295,r^=t;\nreturn te(r)}return\"string\"===e?t.length>xn?re(t):ne(t):\"function\"==typeof t.hashCode?t.hashCode():ie(t)}function re(t){var e=jn[t];return void 0===e&&(e=ne(t),An===kn&&(An=0,jn={}),An++,jn[t]=e),e}function ne(t){for(var e=0,r=0;t.length>r;r++)e=31*e+t.charCodeAt(r)|0;return te(e)}function ie(t){var e=Mn&&Mn.get(t);if(e)return e;if(e=t[On])return e;if(!Dn){if(e=t.propertyIsEnumerable&&t.propertyIsEnumerable[On])return e;if(e=oe(t))return e}if(Object.isExtensible&&!Object.isExtensible(t))throw Error(\"Non-extensible objects are not allowed as keys.\");if(e=++En,1073741824&En&&(En=0),Mn)Mn.set(t,e);else if(Dn)Object.defineProperty(t,On,{enumerable:!1,configurable:!1,writable:!1,value:e});else if(t.propertyIsEnumerable&&t.propertyIsEnumerable===t.constructor.prototype.propertyIsEnumerable)t.propertyIsEnumerable=function(){return this.constructor.prototype.propertyIsEnumerable.apply(this,arguments)},t.propertyIsEnumerable[On]=e;else{if(!t.nodeType)throw Error(\"Unable to set a non-enumerable property on object.\");t[On]=e}return e}function oe(t){if(t&&t.nodeType>0)switch(t.nodeType){case 1:return t.uniqueID;case 9:return t.documentElement&&t.documentElement.uniqueID}}function ue(t,e){if(!t)throw Error(e)}function se(t){ue(1/0!==t,\"Cannot perform this action with an infinite size.\")}function ae(t,e){this._iter=t,this._useKeys=e,this.size=t.size}function he(t){this._iter=t,this.size=t.size}function fe(t){this._iter=t,this.size=t.size}function ce(t){this._iter=t,this.size=t.size}function _e(t){var e=je(t);return e._iter=t,e.size=t.size,e.flip=function(){return t},e.reverse=function(){var e=t.reverse.apply(this);return e.flip=function(){return t.reverse()},e},e.has=function(e){return t.contains(e)},e.contains=function(e){return t.has(e)},e.cacheResult=Re,e.__iterateUncached=function(e,r){var n=this;return t.__iterate(function(t,r){return e(r,t,n)!==!1},r)},e.__iteratorUncached=function(e,r){if(e===gn){var n=t.__iterator(e,r);return new S(function(){var t=n.next();if(!t.done){var e=t.value[0];t.value[0]=t.value[1],t.value[1]=e\n}return t})}return t.__iterator(e===mn?dn:mn,r)},e}function pe(t,e,r){var n=je(t);return n.size=t.size,n.has=function(e){return t.has(e)},n.get=function(n,i){var o=t.get(n,fn);return o===fn?i:e.call(r,o,n,t)},n.__iterateUncached=function(n,i){var o=this;return t.__iterate(function(t,i,u){return n(e.call(r,t,i,u),i,o)!==!1},i)},n.__iteratorUncached=function(n,i){var o=t.__iterator(gn,i);return new S(function(){var i=o.next();if(i.done)return i;var u=i.value,s=u[0];return z(n,s,e.call(r,u[1],s,t),i)})},n}function ve(t,e){var r=je(t);return r._iter=t,r.size=t.size,r.reverse=function(){return t},t.flip&&(r.flip=function(){var e=_e(t);return e.reverse=function(){return t.flip()},e}),r.get=function(r,n){return t.get(e?r:-1-r,n)},r.has=function(r){return t.has(e?r:-1-r)},r.contains=function(e){return t.contains(e)},r.cacheResult=Re,r.__iterate=function(e,r){var n=this;return t.__iterate(function(t,r){return e(t,r,n)},!r)},r.__iterator=function(e,r){return t.__iterator(e,!r)},r}function le(t,e,r,n){var i=je(t);return n&&(i.has=function(n){var i=t.get(n,fn);return i!==fn&&!!e.call(r,i,n,t)},i.get=function(n,i){var o=t.get(n,fn);return o!==fn&&e.call(r,o,n,t)?o:i}),i.__iterateUncached=function(i,o){var u=this,s=0;return t.__iterate(function(t,o,a){return e.call(r,t,o,a)?(s++,i(t,n?o:s-1,u)):void 0},o),s},i.__iteratorUncached=function(i,o){var u=t.__iterator(gn,o),s=0;return new S(function(){for(;;){var o=u.next();if(o.done)return o;var a=o.value,h=a[0],f=a[1];if(e.call(r,f,h,t))return z(i,n?h:s++,f,o)}})},i}function ye(t,e,r){var n=Le().asMutable();return t.__iterate(function(i,o){n.update(e.call(r,i,o,t),0,function(t){return t+1})}),n.asImmutable()}function de(t,e,r){var n=d(t),i=(w(t)?Ir():Le()).asMutable();t.__iterate(function(o,u){i.update(e.call(r,o,u,t),function(t){return t=t||[],t.push(n?[u,o]:o),t})});var o=Ae(t);return i.map(function(e){return Oe(t,o(e))})}function me(t,e,r,n){var i=t.size;if(a(e,r,i))return t;var o=h(e,i),s=f(r,i);if(o!==o||s!==s)return me(t.toSeq().cacheResult(),e,r,n);var c=s-o;0>c&&(c=0);var _=je(t);\nreturn _.size=0===c?c:t.size&&c||void 0,!n&&L(t)&&c>=0&&(_.get=function(e,r){return e=u(this,e),e>=0&&c>e?t.get(e+o,r):r}),_.__iterateUncached=function(e,r){var i=this;if(0===c)return 0;if(r)return this.cacheResult().__iterate(e,r);var u=0,s=!0,a=0;return t.__iterate(function(t,r){return s&&(s=u++<o)?void 0:(a++,e(t,n?r:a-1,i)!==!1&&a!==c)}),a},_.__iteratorUncached=function(e,r){if(c&&r)return this.cacheResult().__iterator(e,r);var i=c&&t.__iterator(e,r),u=0,s=0;return new S(function(){for(;u++!==o;)i.next();if(++s>c)return I();var t=i.next();return n||e===mn?t:e===dn?z(e,s-1,void 0,t):z(e,s-1,t.value[1],t)})},_}function ge(t,e,r){var n=je(t);return n.__iterateUncached=function(n,i){var o=this;if(i)return this.cacheResult().__iterate(n,i);var u=0;return t.__iterate(function(t,i,s){return e.call(r,t,i,s)&&++u&&n(t,i,o)}),u},n.__iteratorUncached=function(n,i){var o=this;if(i)return this.cacheResult().__iterator(n,i);var u=t.__iterator(gn,i),s=!0;return new S(function(){if(!s)return I();var t=u.next();if(t.done)return t;var i=t.value,a=i[0],h=i[1];return e.call(r,h,a,o)?n===gn?t:z(n,a,h,t):(s=!1,I())})},n}function we(t,e,r,n){var i=je(t);return i.__iterateUncached=function(i,o){var u=this;if(o)return this.cacheResult().__iterate(i,o);var s=!0,a=0;return t.__iterate(function(t,o,h){return s&&(s=e.call(r,t,o,h))?void 0:(a++,i(t,n?o:a-1,u))}),a},i.__iteratorUncached=function(i,o){var u=this;if(o)return this.cacheResult().__iterator(i,o);var s=t.__iterator(gn,o),a=!0,h=0;return new S(function(){var t,o,f;do{if(t=s.next(),t.done)return n||i===mn?t:i===dn?z(i,h++,void 0,t):z(i,h++,t.value[1],t);var c=t.value;o=c[0],f=c[1],a&&(a=e.call(r,f,o,u))}while(a);return i===gn?t:z(i,o,f,t)})},i}function Se(t,e){var r=d(t),n=[t].concat(e).map(function(t){return y(t)?r&&(t=p(t)):t=r?W(t):B(Array.isArray(t)?t:[t]),t}).filter(function(t){return 0!==t.size});if(0===n.length)return t;if(1===n.length){var i=n[0];if(i===t||r&&d(i)||m(t)&&m(i))return i}var o=new j(n);return r?o=o.toKeyedSeq():m(t)||(o=o.toSetSeq()),o=o.flatten(!0),o.size=n.reduce(function(t,e){if(void 0!==t){var r=e.size;\nif(void 0!==r)return t+r}},0),o}function ze(t,e,r){var n=je(t);return n.__iterateUncached=function(n,i){function o(t,a){var h=this;t.__iterate(function(t,i){return(!e||e>a)&&y(t)?o(t,a+1):n(t,r?i:u++,h)===!1&&(s=!0),!s},i)}var u=0,s=!1;return o(t,0),u},n.__iteratorUncached=function(n,i){var o=t.__iterator(n,i),u=[],s=0;return new S(function(){for(;o;){var t=o.next();if(t.done===!1){var a=t.value;if(n===gn&&(a=a[1]),e&&!(e>u.length)||!y(a))return r?t:z(n,s++,a,t);u.push(o),o=a.__iterator(n,i)}else o=u.pop()}return I()})},n}function Ie(t,e,r){var n=Ae(t);return t.toSeq().map(function(i,o){return n(e.call(r,i,o,t))}).flatten(!0)}function be(t,e){var r=je(t);return r.size=t.size&&2*t.size-1,r.__iterateUncached=function(r,n){var i=this,o=0;return t.__iterate(function(t){return(!o||r(e,o++,i)!==!1)&&r(t,o++,i)!==!1},n),o},r.__iteratorUncached=function(r,n){var i,o=t.__iterator(mn,n),u=0;return new S(function(){return(!i||u%2)&&(i=o.next(),i.done)?i:u%2?z(r,u++,e):z(r,u++,i.value,i)})},r}function qe(t,e,r){e||(e=Ue);var n=d(t),i=0,o=t.toSeq().map(function(e,n){return[n,e,i++,r?r(e,n,t):e]}).toArray();return o.sort(function(t,r){return e(t[3],r[3])||t[2]-r[2]}).forEach(n?function(t,e){o[e].length=2}:function(t,e){o[e]=t[1]}),n?x(o):m(t)?k(o):A(o)}function De(t,e,r){if(e||(e=Ue),r){var n=t.toSeq().map(function(e,n){return[e,r(e,n,t)]}).reduce(function(t,r){return Me(e,t[1],r[1])?r:t});return n&&n[0]}return t.reduce(function(t,r){return Me(e,t,r)?r:t})}function Me(t,e,r){var n=t(r,e);return 0===n&&r!==e&&(void 0===r||null===r||r!==r)||n>0}function Ee(t,e,r){var n=je(t);return n.size=new j(r).map(function(t){return t.size}).min(),n.__iterate=function(t,e){for(var r,n=this.__iterator(mn,e),i=0;!(r=n.next()).done&&t(r.value,i++,this)!==!1;);return i},n.__iteratorUncached=function(t,n){var i=r.map(function(t){return t=_(t),D(n?t.reverse():t)}),o=0,u=!1;return new S(function(){var r;return u||(r=i.map(function(t){return t.next()}),u=r.some(function(t){return t.done})),u?I():z(t,o++,e.apply(null,r.map(function(t){return t.value})))\n})},n}function Oe(t,e){return L(t)?e:t.constructor(e)}function xe(t){if(t!==Object(t))throw new TypeError(\"Expected [K, V] tuple: \"+t)}function ke(t){return se(t.size),o(t)}function Ae(t){return d(t)?p:m(t)?v:l}function je(t){return Object.create((d(t)?x:m(t)?k:A).prototype)}function Re(){return this._iter.cacheResult?(this._iter.cacheResult(),this.size=this._iter.size,this):O.prototype.cacheResult.call(this)}function Ue(t,e){return t>e?1:e>t?-1:0}function Ke(t){var e=D(t);if(!e){if(!E(t))throw new TypeError(\"Expected iterable or array-like: \"+t);e=D(_(t))}return e}function Le(t){return null===t||void 0===t?Qe():Te(t)?t:Qe().withMutations(function(e){var r=p(t);se(r.size),r.forEach(function(t,r){return e.set(r,t)})})}function Te(t){return!(!t||!t[Rn])}function We(t,e){this.ownerID=t,this.entries=e}function Be(t,e,r){this.ownerID=t,this.bitmap=e,this.nodes=r}function Ce(t,e,r){this.ownerID=t,this.count=e,this.nodes=r}function Je(t,e,r){this.ownerID=t,this.keyHash=e,this.entries=r}function Pe(t,e,r){this.ownerID=t,this.keyHash=e,this.entry=r}function He(t,e,r){this._type=e,this._reverse=r,this._stack=t._root&&Ve(t._root)}function Ne(t,e){return z(t,e[0],e[1])}function Ve(t,e){return{node:t,index:0,__prev:e}}function Ye(t,e,r,n){var i=Object.create(Un);return i.size=t,i._root=e,i.__ownerID=r,i.__hash=n,i.__altered=!1,i}function Qe(){return Kn||(Kn=Ye(0))}function Xe(t,r,n){var i,o;if(t._root){var u=e(cn),s=e(_n);if(i=Fe(t._root,t.__ownerID,0,void 0,r,n,u,s),!s.value)return t;o=t.size+(u.value?n===fn?-1:1:0)}else{if(n===fn)return t;o=1,i=new We(t.__ownerID,[[r,n]])}return t.__ownerID?(t.size=o,t._root=i,t.__hash=void 0,t.__altered=!0,t):i?Ye(o,i):Qe()}function Fe(t,e,n,i,o,u,s,a){return t?t.update(e,n,i,o,u,s,a):u===fn?t:(r(a),r(s),new Pe(e,i,[o,u]))}function Ge(t){return t.constructor===Pe||t.constructor===Je}function Ze(t,e,r,n,i){if(t.keyHash===n)return new Je(e,n,[t.entry,i]);var o,u=(0===r?t.keyHash:t.keyHash>>>r)&hn,s=(0===r?n:n>>>r)&hn,a=u===s?[Ze(t,e,r+sn,n,i)]:(o=new Pe(e,n,i),s>u?[t,o]:[o,t]);return new Be(e,1<<u|1<<s,a)\n}function $e(t,e,r,i){t||(t=new n);for(var o=new Pe(t,ee(r),[r,i]),u=0;e.length>u;u++){var s=e[u];o=o.update(t,0,void 0,s[0],s[1])}return o}function tr(t,e,r,n){for(var i=0,o=0,u=Array(r),s=0,a=1,h=e.length;h>s;s++,a<<=1){var f=e[s];void 0!==f&&s!==n&&(i|=a,u[o++]=f)}return new Be(t,i,u)}function er(t,e,r,n,i){for(var o=0,u=Array(an),s=0;0!==r;s++,r>>>=1)u[s]=1&r?e[o++]:void 0;return u[n]=i,new Ce(t,o+1,u)}function rr(t,e,r){for(var n=[],i=0;r.length>i;i++){var o=r[i],u=p(o);y(o)||(u=u.map(function(t){return F(t)})),n.push(u)}return ir(t,e,n)}function nr(t){return function(e,r){return e&&e.mergeDeepWith&&y(r)?e.mergeDeepWith(t,r):t?t(e,r):r}}function ir(t,e,r){return r=r.filter(function(t){return 0!==t.size}),0===r.length?t:0===t.size&&1===r.length?t.constructor(r[0]):t.withMutations(function(t){for(var n=e?function(r,n){t.update(n,fn,function(t){return t===fn?r:e(t,r)})}:function(e,r){t.set(r,e)},i=0;r.length>i;i++)r[i].forEach(n)})}function or(t,e,r,n){var i=t===fn,o=e.next();if(o.done){var u=i?r:t,s=n(u);return s===u?t:s}ue(i||t&&t.set,\"invalid keyPath\");var a=o.value,h=i?fn:t.get(a,fn),f=or(h,e,r,n);return f===h?t:f===fn?t.remove(a):(i?Qe():t).set(a,f)}function ur(t){return t-=t>>1&1431655765,t=(858993459&t)+(t>>2&858993459),t=t+(t>>4)&252645135,t+=t>>8,t+=t>>16,127&t}function sr(t,e,r,n){var o=n?t:i(t);return o[e]=r,o}function ar(t,e,r,n){var i=t.length+1;if(n&&e+1===i)return t[e]=r,t;for(var o=Array(i),u=0,s=0;i>s;s++)s===e?(o[s]=r,u=-1):o[s]=t[s+u];return o}function hr(t,e,r){var n=t.length-1;if(r&&e===n)return t.pop(),t;for(var i=Array(n),o=0,u=0;n>u;u++)u===e&&(o=1),i[u]=t[u+o];return i}function fr(t){var e=lr();if(null===t||void 0===t)return e;if(cr(t))return t;var r=v(t),n=r.size;return 0===n?e:(se(n),n>0&&an>n?vr(0,n,sn,null,new _r(r.toArray())):e.withMutations(function(t){t.setSize(n),r.forEach(function(e,r){return t.set(r,e)})}))}function cr(t){return!(!t||!t[Bn])}function _r(t,e){this.array=t,this.ownerID=e}function pr(t,e){function r(t,e,r){return 0===e?n(t,r):i(t,e,r)}function n(t,r){var n=r===s?a&&a.array:t&&t.array,i=r>o?0:o-r,h=u-r;\nreturn h>an&&(h=an),function(){if(i===h)return Pn;var t=e?--h:i++;return n&&n[t]}}function i(t,n,i){var s,a=t&&t.array,h=i>o?0:o-i>>n,f=(u-i>>n)+1;return f>an&&(f=an),function(){for(;;){if(s){var t=s();if(t!==Pn)return t;s=null}if(h===f)return Pn;var o=e?--f:h++;s=r(a&&a[o],n-sn,i+(o<<n))}}}var o=t._origin,u=t._capacity,s=zr(u),a=t._tail;return r(t._root,t._level,0)}function vr(t,e,r,n,i,o,u){var s=Object.create(Cn);return s.size=e-t,s._origin=t,s._capacity=e,s._level=r,s._root=n,s._tail=i,s.__ownerID=o,s.__hash=u,s.__altered=!1,s}function lr(){return Jn||(Jn=vr(0,0,sn))}function yr(t,r,n){if(r=u(t,r),r>=t.size||0>r)return t.withMutations(function(t){0>r?wr(t,r).set(0,n):wr(t,0,r+1).set(r,n)});r+=t._origin;var i=t._tail,o=t._root,s=e(_n);return r>=zr(t._capacity)?i=dr(i,t.__ownerID,0,r,n,s):o=dr(o,t.__ownerID,t._level,r,n,s),s.value?t.__ownerID?(t._root=o,t._tail=i,t.__hash=void 0,t.__altered=!0,t):vr(t._origin,t._capacity,t._level,o,i):t}function dr(t,e,n,i,o,u){var s=i>>>n&hn,a=t&&t.array.length>s;if(!a&&void 0===o)return t;var h;if(n>0){var f=t&&t.array[s],c=dr(f,e,n-sn,i,o,u);return c===f?t:(h=mr(t,e),h.array[s]=c,h)}return a&&t.array[s]===o?t:(r(u),h=mr(t,e),void 0===o&&s===h.array.length-1?h.array.pop():h.array[s]=o,h)}function mr(t,e){return e&&t&&e===t.ownerID?t:new _r(t?t.array.slice():[],e)}function gr(t,e){if(e>=zr(t._capacity))return t._tail;if(1<<t._level+sn>e){for(var r=t._root,n=t._level;r&&n>0;)r=r.array[e>>>n&hn],n-=sn;return r}}function wr(t,e,r){var i=t.__ownerID||new n,o=t._origin,u=t._capacity,s=o+e,a=void 0===r?u:0>r?u+r:o+r;if(s===o&&a===u)return t;if(s>=a)return t.clear();for(var h=t._level,f=t._root,c=0;0>s+c;)f=new _r(f&&f.array.length?[void 0,f]:[],i),h+=sn,c+=1<<h;c&&(s+=c,o+=c,a+=c,u+=c);for(var _=zr(u),p=zr(a);p>=1<<h+sn;)f=new _r(f&&f.array.length?[f]:[],i),h+=sn;var v=t._tail,l=_>p?gr(t,a-1):p>_?new _r([],i):v;if(v&&p>_&&u>s&&v.array.length){f=mr(f,i);for(var y=f,d=h;d>sn;d-=sn){var m=_>>>d&hn;y=y.array[m]=mr(y.array[m],i)}y.array[_>>>sn&hn]=v}if(u>a&&(l=l&&l.removeAfter(i,0,a)),s>=p)s-=p,a-=p,h=sn,f=null,l=l&&l.removeBefore(i,0,s);\nelse if(s>o||_>p){for(c=0;f;){var g=s>>>h&hn;if(g!==p>>>h&hn)break;g&&(c+=(1<<h)*g),h-=sn,f=f.array[g]}f&&s>o&&(f=f.removeBefore(i,h,s-c)),f&&_>p&&(f=f.removeAfter(i,h,p-c)),c&&(s-=c,a-=c)}return t.__ownerID?(t.size=a-s,t._origin=s,t._capacity=a,t._level=h,t._root=f,t._tail=l,t.__hash=void 0,t.__altered=!0,t):vr(s,a,h,f,l)}function Sr(t,e,r){for(var n=[],i=0,o=0;r.length>o;o++){var u=r[o],s=v(u);s.size>i&&(i=s.size),y(u)||(s=s.map(function(t){return F(t)})),n.push(s)}return i>t.size&&(t=t.setSize(i)),ir(t,e,n)}function zr(t){return an>t?0:t-1>>>sn<<sn}function Ir(t){return null===t||void 0===t?Dr():br(t)?t:Dr().withMutations(function(e){var r=p(t);se(r.size),r.forEach(function(t,r){return e.set(r,t)})})}function br(t){return Te(t)&&w(t)}function qr(t,e,r,n){var i=Object.create(Ir.prototype);return i.size=t?t.size:0,i._map=t,i._list=e,i.__ownerID=r,i.__hash=n,i}function Dr(){return Hn||(Hn=qr(Qe(),lr()))}function Mr(t,e,r){var n,i,o=t._map,u=t._list,s=o.get(e),a=void 0!==s;if(r===fn){if(!a)return t;u.size>=an&&u.size>=2*o.size?(i=u.filter(function(t,e){return void 0!==t&&s!==e}),n=i.toKeyedSeq().map(function(t){return t[0]}).flip().toMap(),t.__ownerID&&(n.__ownerID=i.__ownerID=t.__ownerID)):(n=o.remove(e),i=s===u.size-1?u.pop():u.set(s,void 0))}else if(a){if(r===u.get(s)[1])return t;n=o,i=u.set(s,[e,r])}else n=o.set(e,u.size),i=u.set(u.size,[e,r]);return t.__ownerID?(t.size=n.size,t._map=n,t._list=i,t.__hash=void 0,t):qr(n,i)}function Er(t){return null===t||void 0===t?kr():Or(t)?t:kr().unshiftAll(t)}function Or(t){return!(!t||!t[Nn])}function xr(t,e,r,n){var i=Object.create(Vn);return i.size=t,i._head=e,i.__ownerID=r,i.__hash=n,i.__altered=!1,i}function kr(){return Yn||(Yn=xr(0))}function Ar(t){return null===t||void 0===t?Kr():jr(t)?t:Kr().withMutations(function(e){var r=l(t);se(r.size),r.forEach(function(t){return e.add(t)})})}function jr(t){return!(!t||!t[Qn])}function Rr(t,e){return t.__ownerID?(t.size=e.size,t._map=e,t):e===t._map?t:0===e.size?t.__empty():t.__make(e)}function Ur(t,e){var r=Object.create(Xn);return r.size=t?t.size:0,r._map=t,r.__ownerID=e,r\n}function Kr(){return Fn||(Fn=Ur(Qe()))}function Lr(t){return null===t||void 0===t?Br():Tr(t)?t:Br().withMutations(function(e){var r=l(t);se(r.size),r.forEach(function(t){return e.add(t)})})}function Tr(t){return jr(t)&&w(t)}function Wr(t,e){var r=Object.create(Gn);return r.size=t?t.size:0,r._map=t,r.__ownerID=e,r}function Br(){return Zn||(Zn=Wr(Dr()))}function Cr(t,e){var r=function(t){return this instanceof r?void(this._map=Le(t)):new r(t)},n=Object.keys(t),i=r.prototype=Object.create($n);i.constructor=r,e&&(i._name=e),i._defaultValues=t,i._keys=n,i.size=n.length;try{n.forEach(function(t){Object.defineProperty(r.prototype,t,{get:function(){return this.get(t)},set:function(e){ue(this.__ownerID,\"Cannot set on an immutable record.\"),this.set(t,e)}})})}catch(o){}return r}function Jr(t,e,r){var n=Object.create(Object.getPrototypeOf(t));return n._map=e,n.__ownerID=r,n}function Pr(t){return t._name||t.constructor.name}function Hr(t,e){if(t===e)return!0;if(!y(e)||void 0!==t.size&&void 0!==e.size&&t.size!==e.size||void 0!==t.__hash&&void 0!==e.__hash&&t.__hash!==e.__hash||d(t)!==d(e)||m(t)!==m(e)||w(t)!==w(e))return!1;if(0===t.size&&0===e.size)return!0;var r=!g(t);if(w(t)){var n=t.entries();return e.every(function(t,e){var i=n.next().value;return i&&X(i[1],t)&&(r||X(i[0],e))})&&n.next().done}var i=!1;if(void 0===t.size)if(void 0===e.size)t.cacheResult();else{i=!0;var o=t;t=e,e=o}var u=!0,s=e.__iterate(function(e,n){return(r?t.has(e):i?X(e,t.get(n,fn)):X(t.get(n,fn),e))?void 0:(u=!1,!1)});return u&&t.size===s}function Nr(t,e,r){if(!(this instanceof Nr))return new Nr(t,e,r);if(ue(0!==r,\"Cannot step a Range by 0\"),t=t||0,void 0===e&&(e=1/0),r=void 0===r?1:Math.abs(r),t>e&&(r=-r),this._start=t,this._end=e,this._step=r,this.size=Math.max(0,Math.ceil((e-t)/r-1)+1),0===this.size){if(ti)return ti;ti=this}}function Vr(t,e){if(!(this instanceof Vr))return new Vr(t,e);if(this._value=t,this.size=void 0===e?1/0:Math.max(0,e),0===this.size){if(ei)return ei;ei=this}}function Yr(t,e){var r=function(r){t.prototype[r]=e[r]};return Object.keys(e).forEach(r),Object.getOwnPropertySymbols&&Object.getOwnPropertySymbols(e).forEach(r),t\n}function Qr(t,e){return e}function Xr(t,e){return[e,t]}function Fr(t){return function(){return!t.apply(this,arguments)}}function Gr(t){return function(){return-t.apply(this,arguments)}}function Zr(t){return\"string\"==typeof t?JSON.stringify(t):t}function $r(){return i(arguments)}function tn(t,e){return e>t?1:t>e?-1:0}function en(t){if(1/0===t.size)return 0;var e=w(t),r=d(t),n=e?1:0,i=t.__iterate(r?e?function(t,e){n=31*n+nn(ee(t),ee(e))|0}:function(t,e){n=n+nn(ee(t),ee(e))|0}:e?function(t){n=31*n+ee(t)|0}:function(t){n=n+ee(t)|0});return rn(i,n)}function rn(t,e){return e=qn(e,3432918353),e=qn(e<<15|e>>>-15,461845907),e=qn(e<<13|e>>>-13,5),e=(e+3864292196|0)^t,e=qn(e^e>>>16,2246822507),e=qn(e^e>>>13,3266489909),e=te(e^e>>>16)}function nn(t,e){return t^e+2654435769+(t<<6)+(t>>2)|0}var on=Array.prototype.slice,un=\"delete\",sn=5,an=1<<sn,hn=an-1,fn={},cn={value:!1},_n={value:!1};t(p,_),t(v,_),t(l,_),_.isIterable=y,_.isKeyed=d,_.isIndexed=m,_.isAssociative=g,_.isOrdered=w,_.Keyed=p,_.Indexed=v,_.Set=l;var pn=\"@@__IMMUTABLE_ITERABLE__@@\",vn=\"@@__IMMUTABLE_KEYED__@@\",ln=\"@@__IMMUTABLE_INDEXED__@@\",yn=\"@@__IMMUTABLE_ORDERED__@@\",dn=0,mn=1,gn=2,wn=\"function\"==typeof Symbol&&Symbol.iterator,Sn=\"@@iterator\",zn=wn||Sn;S.prototype.toString=function(){return\"[Iterator]\"},S.KEYS=dn,S.VALUES=mn,S.ENTRIES=gn,S.prototype.inspect=S.prototype.toSource=function(){return\"\"+this},S.prototype[zn]=function(){return this},t(O,_),O.of=function(){return O(arguments)},O.prototype.toSeq=function(){return this},O.prototype.toString=function(){return this.__toString(\"Seq {\",\"}\")},O.prototype.cacheResult=function(){return!this._cache&&this.__iterateUncached&&(this._cache=this.entrySeq().toArray(),this.size=this._cache.length),this},O.prototype.__iterate=function(t,e){return P(this,t,e,!0)},O.prototype.__iterator=function(t,e){return H(this,t,e,!0)},t(x,O),x.prototype.toKeyedSeq=function(){return this},t(k,O),k.of=function(){return k(arguments)},k.prototype.toIndexedSeq=function(){return this},k.prototype.toString=function(){return this.__toString(\"Seq [\",\"]\")\n},k.prototype.__iterate=function(t,e){return P(this,t,e,!1)},k.prototype.__iterator=function(t,e){return H(this,t,e,!1)},t(A,O),A.of=function(){return A(arguments)},A.prototype.toSetSeq=function(){return this},O.isSeq=L,O.Keyed=x,O.Set=A,O.Indexed=k;var In=\"@@__IMMUTABLE_SEQ__@@\";O.prototype[In]=!0,t(j,k),j.prototype.get=function(t,e){return this.has(t)?this._array[u(this,t)]:e},j.prototype.__iterate=function(t,e){for(var r=this._array,n=r.length-1,i=0;n>=i;i++)if(t(r[e?n-i:i],i,this)===!1)return i+1;return i},j.prototype.__iterator=function(t,e){var r=this._array,n=r.length-1,i=0;return new S(function(){return i>n?I():z(t,i,r[e?n-i++:i++])})},t(R,x),R.prototype.get=function(t,e){return void 0===e||this.has(t)?this._object[t]:e},R.prototype.has=function(t){return this._object.hasOwnProperty(t)},R.prototype.__iterate=function(t,e){for(var r=this._object,n=this._keys,i=n.length-1,o=0;i>=o;o++){var u=n[e?i-o:o];if(t(r[u],u,this)===!1)return o+1}return o},R.prototype.__iterator=function(t,e){var r=this._object,n=this._keys,i=n.length-1,o=0;return new S(function(){var u=n[e?i-o:o];return o++>i?I():z(t,u,r[u])})},R.prototype[yn]=!0,t(U,k),U.prototype.__iterateUncached=function(t,e){if(e)return this.cacheResult().__iterate(t,e);var r=this._iterable,n=D(r),i=0;if(q(n))for(var o;!(o=n.next()).done&&t(o.value,i++,this)!==!1;);return i},U.prototype.__iteratorUncached=function(t,e){if(e)return this.cacheResult().__iterator(t,e);var r=this._iterable,n=D(r);if(!q(n))return new S(I);var i=0;return new S(function(){var e=n.next();return e.done?e:z(t,i++,e.value)})},t(K,k),K.prototype.__iterateUncached=function(t,e){if(e)return this.cacheResult().__iterate(t,e);for(var r=this._iterator,n=this._iteratorCache,i=0;n.length>i;)if(t(n[i],i++,this)===!1)return i;for(var o;!(o=r.next()).done;){var u=o.value;if(n[i]=u,t(u,i++,this)===!1)break}return i},K.prototype.__iteratorUncached=function(t,e){if(e)return this.cacheResult().__iterator(t,e);var r=this._iterator,n=this._iteratorCache,i=0;return new S(function(){if(i>=n.length){var e=r.next();\nif(e.done)return e;n[i]=e.value}return z(t,i,n[i++])})};var bn;t(N,_),t(V,N),t(Y,N),t(Q,N),N.Keyed=V,N.Indexed=Y,N.Set=Q;var qn=\"function\"==typeof Math.imul&&-2===Math.imul(4294967295,2)?Math.imul:function(t,e){t=0|t,e=0|e;var r=65535&t,n=65535&e;return r*n+((t>>>16)*n+r*(e>>>16)<<16>>>0)|0},Dn=function(){try{return Object.defineProperty({},\"@\",{}),!0}catch(t){return!1}}(),Mn=\"function\"==typeof WeakMap&&new WeakMap,En=0,On=\"__immutablehash__\";\"function\"==typeof Symbol&&(On=Symbol(On));var xn=16,kn=255,An=0,jn={};t(ae,x),ae.prototype.get=function(t,e){return this._iter.get(t,e)},ae.prototype.has=function(t){return this._iter.has(t)},ae.prototype.valueSeq=function(){return this._iter.valueSeq()},ae.prototype.reverse=function(){var t=this,e=ve(this,!0);return this._useKeys||(e.valueSeq=function(){return t._iter.toSeq().reverse()}),e},ae.prototype.map=function(t,e){var r=this,n=pe(this,t,e);return this._useKeys||(n.valueSeq=function(){return r._iter.toSeq().map(t,e)}),n},ae.prototype.__iterate=function(t,e){var r,n=this;return this._iter.__iterate(this._useKeys?function(e,r){return t(e,r,n)}:(r=e?ke(this):0,function(i){return t(i,e?--r:r++,n)}),e)},ae.prototype.__iterator=function(t,e){if(this._useKeys)return this._iter.__iterator(t,e);var r=this._iter.__iterator(mn,e),n=e?ke(this):0;return new S(function(){var i=r.next();return i.done?i:z(t,e?--n:n++,i.value,i)})},ae.prototype[yn]=!0,t(he,k),he.prototype.contains=function(t){return this._iter.contains(t)},he.prototype.__iterate=function(t,e){var r=this,n=0;return this._iter.__iterate(function(e){return t(e,n++,r)},e)},he.prototype.__iterator=function(t,e){var r=this._iter.__iterator(mn,e),n=0;return new S(function(){var e=r.next();return e.done?e:z(t,n++,e.value,e)})},t(fe,A),fe.prototype.has=function(t){return this._iter.contains(t)},fe.prototype.__iterate=function(t,e){var r=this;return this._iter.__iterate(function(e){return t(e,e,r)},e)},fe.prototype.__iterator=function(t,e){var r=this._iter.__iterator(mn,e);return new S(function(){var e=r.next();return e.done?e:z(t,e.value,e.value,e)\n})},t(ce,x),ce.prototype.entrySeq=function(){return this._iter.toSeq()},ce.prototype.__iterate=function(t,e){var r=this;return this._iter.__iterate(function(e){return e?(xe(e),t(e[1],e[0],r)):void 0},e)},ce.prototype.__iterator=function(t,e){var r=this._iter.__iterator(mn,e);return new S(function(){for(;;){var e=r.next();if(e.done)return e;var n=e.value;if(n)return xe(n),t===gn?e:z(t,n[0],n[1],e)}})},he.prototype.cacheResult=ae.prototype.cacheResult=fe.prototype.cacheResult=ce.prototype.cacheResult=Re,t(Le,V),Le.prototype.toString=function(){return this.__toString(\"Map {\",\"}\")},Le.prototype.get=function(t,e){return this._root?this._root.get(0,void 0,t,e):e},Le.prototype.set=function(t,e){return Xe(this,t,e)},Le.prototype.setIn=function(t,e){return this.updateIn(t,fn,function(){return e})},Le.prototype.remove=function(t){return Xe(this,t,fn)},Le.prototype.deleteIn=function(t){return this.updateIn(t,function(){return fn})},Le.prototype.update=function(t,e,r){return 1===arguments.length?t(this):this.updateIn([t],e,r)},Le.prototype.updateIn=function(t,e,r){r||(r=e,e=void 0);var n=or(this,Ke(t),e,r);return n===fn?void 0:n},Le.prototype.clear=function(){return 0===this.size?this:this.__ownerID?(this.size=0,this._root=null,this.__hash=void 0,this.__altered=!0,this):Qe()},Le.prototype.merge=function(){return rr(this,void 0,arguments)},Le.prototype.mergeWith=function(t){var e=on.call(arguments,1);return rr(this,t,e)},Le.prototype.mergeIn=function(t){var e=on.call(arguments,1);return this.updateIn(t,Qe(),function(t){return t.merge.apply(t,e)})},Le.prototype.mergeDeep=function(){return rr(this,nr(void 0),arguments)},Le.prototype.mergeDeepWith=function(t){var e=on.call(arguments,1);return rr(this,nr(t),e)},Le.prototype.mergeDeepIn=function(t){var e=on.call(arguments,1);return this.updateIn(t,Qe(),function(t){return t.mergeDeep.apply(t,e)})},Le.prototype.sort=function(t){return Ir(qe(this,t))},Le.prototype.sortBy=function(t,e){return Ir(qe(this,e,t))},Le.prototype.withMutations=function(t){var e=this.asMutable();return t(e),e.wasAltered()?e.__ensureOwner(this.__ownerID):this\n},Le.prototype.asMutable=function(){return this.__ownerID?this:this.__ensureOwner(new n)},Le.prototype.asImmutable=function(){return this.__ensureOwner()},Le.prototype.wasAltered=function(){return this.__altered},Le.prototype.__iterator=function(t,e){return new He(this,t,e)},Le.prototype.__iterate=function(t,e){var r=this,n=0;return this._root&&this._root.iterate(function(e){return n++,t(e[1],e[0],r)},e),n},Le.prototype.__ensureOwner=function(t){return t===this.__ownerID?this:t?Ye(this.size,this._root,t,this.__hash):(this.__ownerID=t,this.__altered=!1,this)},Le.isMap=Te;var Rn=\"@@__IMMUTABLE_MAP__@@\",Un=Le.prototype;Un[Rn]=!0,Un[un]=Un.remove,Un.removeIn=Un.deleteIn,We.prototype.get=function(t,e,r,n){for(var i=this.entries,o=0,u=i.length;u>o;o++)if(X(r,i[o][0]))return i[o][1];return n},We.prototype.update=function(t,e,n,o,u,s,a){for(var h=u===fn,f=this.entries,c=0,_=f.length;_>c&&!X(o,f[c][0]);c++);var p=_>c;if(p?f[c][1]===u:h)return this;if(r(a),(h||!p)&&r(s),!h||1!==f.length){if(!p&&!h&&f.length>=Ln)return $e(t,f,o,u);var v=t&&t===this.ownerID,l=v?f:i(f);return p?h?c===_-1?l.pop():l[c]=l.pop():l[c]=[o,u]:l.push([o,u]),v?(this.entries=l,this):new We(t,l)}},Be.prototype.get=function(t,e,r,n){void 0===e&&(e=ee(r));var i=1<<((0===t?e:e>>>t)&hn),o=this.bitmap;return 0===(o&i)?n:this.nodes[ur(o&i-1)].get(t+sn,e,r,n)},Be.prototype.update=function(t,e,r,n,i,o,u){void 0===r&&(r=ee(n));var s=(0===e?r:r>>>e)&hn,a=1<<s,h=this.bitmap,f=0!==(h&a);if(!f&&i===fn)return this;var c=ur(h&a-1),_=this.nodes,p=f?_[c]:void 0,v=Fe(p,t,e+sn,r,n,i,o,u);if(v===p)return this;if(!f&&v&&_.length>=Tn)return er(t,_,h,s,v);if(f&&!v&&2===_.length&&Ge(_[1^c]))return _[1^c];if(f&&v&&1===_.length&&Ge(v))return v;var l=t&&t===this.ownerID,y=f?v?h:h^a:h|a,d=f?v?sr(_,c,v,l):hr(_,c,l):ar(_,c,v,l);return l?(this.bitmap=y,this.nodes=d,this):new Be(t,y,d)},Ce.prototype.get=function(t,e,r,n){void 0===e&&(e=ee(r));var i=(0===t?e:e>>>t)&hn,o=this.nodes[i];return o?o.get(t+sn,e,r,n):n},Ce.prototype.update=function(t,e,r,n,i,o,u){void 0===r&&(r=ee(n));var s=(0===e?r:r>>>e)&hn,a=i===fn,h=this.nodes,f=h[s];\nif(a&&!f)return this;var c=Fe(f,t,e+sn,r,n,i,o,u);if(c===f)return this;var _=this.count;if(f){if(!c&&(_--,Wn>_))return tr(t,h,_,s)}else _++;var p=t&&t===this.ownerID,v=sr(h,s,c,p);return p?(this.count=_,this.nodes=v,this):new Ce(t,_,v)},Je.prototype.get=function(t,e,r,n){for(var i=this.entries,o=0,u=i.length;u>o;o++)if(X(r,i[o][0]))return i[o][1];return n},Je.prototype.update=function(t,e,n,o,u,s,a){void 0===n&&(n=ee(o));var h=u===fn;if(n!==this.keyHash)return h?this:(r(a),r(s),Ze(this,t,e,n,[o,u]));for(var f=this.entries,c=0,_=f.length;_>c&&!X(o,f[c][0]);c++);var p=_>c;if(p?f[c][1]===u:h)return this;if(r(a),(h||!p)&&r(s),h&&2===_)return new Pe(t,this.keyHash,f[1^c]);var v=t&&t===this.ownerID,l=v?f:i(f);return p?h?c===_-1?l.pop():l[c]=l.pop():l[c]=[o,u]:l.push([o,u]),v?(this.entries=l,this):new Je(t,this.keyHash,l)},Pe.prototype.get=function(t,e,r,n){return X(r,this.entry[0])?this.entry[1]:n},Pe.prototype.update=function(t,e,n,i,o,u,s){var a=o===fn,h=X(i,this.entry[0]);return(h?o===this.entry[1]:a)?this:(r(s),a?void r(u):h?t&&t===this.ownerID?(this.entry[1]=o,this):new Pe(t,this.keyHash,[i,o]):(r(u),Ze(this,t,e,ee(i),[i,o])))},We.prototype.iterate=Je.prototype.iterate=function(t,e){for(var r=this.entries,n=0,i=r.length-1;i>=n;n++)if(t(r[e?i-n:n])===!1)return!1},Be.prototype.iterate=Ce.prototype.iterate=function(t,e){for(var r=this.nodes,n=0,i=r.length-1;i>=n;n++){var o=r[e?i-n:n];if(o&&o.iterate(t,e)===!1)return!1}},Pe.prototype.iterate=function(t){return t(this.entry)},t(He,S),He.prototype.next=function(){for(var t=this._type,e=this._stack;e;){var r,n=e.node,i=e.index++;if(n.entry){if(0===i)return Ne(t,n.entry)}else if(n.entries){if(r=n.entries.length-1,r>=i)return Ne(t,n.entries[this._reverse?r-i:i])}else if(r=n.nodes.length-1,r>=i){var o=n.nodes[this._reverse?r-i:i];if(o){if(o.entry)return Ne(t,o.entry);e=this._stack=Ve(o,e)}continue}e=this._stack=this._stack.__prev}return I()};var Kn,Ln=an/4,Tn=an/2,Wn=an/4;t(fr,Y),fr.of=function(){return this(arguments)},fr.prototype.toString=function(){return this.__toString(\"List [\",\"]\")\n},fr.prototype.get=function(t,e){if(t=u(this,t),0>t||t>=this.size)return e;t+=this._origin;var r=gr(this,t);return r&&r.array[t&hn]},fr.prototype.set=function(t,e){return yr(this,t,e)},fr.prototype.remove=function(t){return this.has(t)?0===t?this.shift():t===this.size-1?this.pop():this.splice(t,1):this},fr.prototype.clear=function(){return 0===this.size?this:this.__ownerID?(this.size=this._origin=this._capacity=0,this._level=sn,this._root=this._tail=null,this.__hash=void 0,this.__altered=!0,this):lr()},fr.prototype.push=function(){var t=arguments,e=this.size;return this.withMutations(function(r){wr(r,0,e+t.length);for(var n=0;t.length>n;n++)r.set(e+n,t[n])})},fr.prototype.pop=function(){return wr(this,0,-1)},fr.prototype.unshift=function(){var t=arguments;return this.withMutations(function(e){wr(e,-t.length);for(var r=0;t.length>r;r++)e.set(r,t[r])})},fr.prototype.shift=function(){return wr(this,1)},fr.prototype.merge=function(){return Sr(this,void 0,arguments)},fr.prototype.mergeWith=function(t){var e=on.call(arguments,1);return Sr(this,t,e)},fr.prototype.mergeDeep=function(){return Sr(this,nr(void 0),arguments)},fr.prototype.mergeDeepWith=function(t){var e=on.call(arguments,1);return Sr(this,nr(t),e)},fr.prototype.setSize=function(t){return wr(this,0,t)},fr.prototype.slice=function(t,e){var r=this.size;return a(t,e,r)?this:wr(this,h(t,r),f(e,r))},fr.prototype.__iterator=function(t,e){var r=0,n=pr(this,e);return new S(function(){var e=n();return e===Pn?I():z(t,r++,e)})},fr.prototype.__iterate=function(t,e){for(var r,n=0,i=pr(this,e);(r=i())!==Pn&&t(r,n++,this)!==!1;);return n},fr.prototype.__ensureOwner=function(t){return t===this.__ownerID?this:t?vr(this._origin,this._capacity,this._level,this._root,this._tail,t,this.__hash):(this.__ownerID=t,this)},fr.isList=cr;var Bn=\"@@__IMMUTABLE_LIST__@@\",Cn=fr.prototype;Cn[Bn]=!0,Cn[un]=Cn.remove,Cn.setIn=Un.setIn,Cn.deleteIn=Cn.removeIn=Un.removeIn,Cn.update=Un.update,Cn.updateIn=Un.updateIn,Cn.mergeIn=Un.mergeIn,Cn.mergeDeepIn=Un.mergeDeepIn,Cn.withMutations=Un.withMutations,Cn.asMutable=Un.asMutable,Cn.asImmutable=Un.asImmutable,Cn.wasAltered=Un.wasAltered,_r.prototype.removeBefore=function(t,e,r){if(r===e?1<<e:0||0===this.array.length)return this;\nvar n=r>>>e&hn;if(n>=this.array.length)return new _r([],t);var i,o=0===n;if(e>0){var u=this.array[n];if(i=u&&u.removeBefore(t,e-sn,r),i===u&&o)return this}if(o&&!i)return this;var s=mr(this,t);if(!o)for(var a=0;n>a;a++)s.array[a]=void 0;return i&&(s.array[n]=i),s},_r.prototype.removeAfter=function(t,e,r){if(r===e?1<<e:0||0===this.array.length)return this;var n=r-1>>>e&hn;if(n>=this.array.length)return this;var i,o=n===this.array.length-1;if(e>0){var u=this.array[n];if(i=u&&u.removeAfter(t,e-sn,r),i===u&&o)return this}if(o&&!i)return this;var s=mr(this,t);return o||s.array.pop(),i&&(s.array[n]=i),s};var Jn,Pn={};t(Ir,Le),Ir.of=function(){return this(arguments)},Ir.prototype.toString=function(){return this.__toString(\"OrderedMap {\",\"}\")},Ir.prototype.get=function(t,e){var r=this._map.get(t);return void 0!==r?this._list.get(r)[1]:e},Ir.prototype.clear=function(){return 0===this.size?this:this.__ownerID?(this.size=0,this._map.clear(),this._list.clear(),this):Dr()},Ir.prototype.set=function(t,e){return Mr(this,t,e)},Ir.prototype.remove=function(t){return Mr(this,t,fn)},Ir.prototype.wasAltered=function(){return this._map.wasAltered()||this._list.wasAltered()},Ir.prototype.__iterate=function(t,e){var r=this;return this._list.__iterate(function(e){return e&&t(e[1],e[0],r)},e)},Ir.prototype.__iterator=function(t,e){return this._list.fromEntrySeq().__iterator(t,e)},Ir.prototype.__ensureOwner=function(t){if(t===this.__ownerID)return this;var e=this._map.__ensureOwner(t),r=this._list.__ensureOwner(t);return t?qr(e,r,t,this.__hash):(this.__ownerID=t,this._map=e,this._list=r,this)},Ir.isOrderedMap=br,Ir.prototype[yn]=!0,Ir.prototype[un]=Ir.prototype.remove;var Hn;t(Er,Y),Er.of=function(){return this(arguments)},Er.prototype.toString=function(){return this.__toString(\"Stack [\",\"]\")},Er.prototype.get=function(t,e){for(var r=this._head;r&&t--;)r=r.next;return r?r.value:e},Er.prototype.peek=function(){return this._head&&this._head.value},Er.prototype.push=function(){if(0===arguments.length)return this;for(var t=this.size+arguments.length,e=this._head,r=arguments.length-1;r>=0;r--)e={value:arguments[r],next:e};\nreturn this.__ownerID?(this.size=t,this._head=e,this.__hash=void 0,this.__altered=!0,this):xr(t,e)},Er.prototype.pushAll=function(t){if(t=v(t),0===t.size)return this;se(t.size);var e=this.size,r=this._head;return t.reverse().forEach(function(t){e++,r={value:t,next:r}}),this.__ownerID?(this.size=e,this._head=r,this.__hash=void 0,this.__altered=!0,this):xr(e,r)},Er.prototype.pop=function(){return this.slice(1)},Er.prototype.unshift=function(){return this.push.apply(this,arguments)},Er.prototype.unshiftAll=function(t){return this.pushAll(t)},Er.prototype.shift=function(){return this.pop.apply(this,arguments)},Er.prototype.clear=function(){return 0===this.size?this:this.__ownerID?(this.size=0,this._head=void 0,this.__hash=void 0,this.__altered=!0,this):kr()},Er.prototype.slice=function(t,e){if(a(t,e,this.size))return this;var r=h(t,this.size),n=f(e,this.size);if(n!==this.size)return Y.prototype.slice.call(this,t,e);for(var i=this.size-r,o=this._head;r--;)o=o.next;return this.__ownerID?(this.size=i,this._head=o,this.__hash=void 0,this.__altered=!0,this):xr(i,o)},Er.prototype.__ensureOwner=function(t){return t===this.__ownerID?this:t?xr(this.size,this._head,t,this.__hash):(this.__ownerID=t,this.__altered=!1,this)},Er.prototype.__iterate=function(t,e){if(e)return this.toSeq().cacheResult.__iterate(t,e);for(var r=0,n=this._head;n&&t(n.value,r++,this)!==!1;)n=n.next;return r},Er.prototype.__iterator=function(t,e){if(e)return this.toSeq().cacheResult().__iterator(t,e);var r=0,n=this._head;return new S(function(){if(n){var e=n.value;return n=n.next,z(t,r++,e)}return I()})},Er.isStack=Or;var Nn=\"@@__IMMUTABLE_STACK__@@\",Vn=Er.prototype;Vn[Nn]=!0,Vn.withMutations=Un.withMutations,Vn.asMutable=Un.asMutable,Vn.asImmutable=Un.asImmutable,Vn.wasAltered=Un.wasAltered;var Yn;t(Ar,Q),Ar.of=function(){return this(arguments)},Ar.fromKeys=function(t){return this(p(t).keySeq())},Ar.prototype.toString=function(){return this.__toString(\"Set {\",\"}\")},Ar.prototype.has=function(t){return this._map.has(t)},Ar.prototype.add=function(t){return Rr(this,this._map.set(t,!0))\n},Ar.prototype.remove=function(t){return Rr(this,this._map.remove(t))},Ar.prototype.clear=function(){return Rr(this,this._map.clear())},Ar.prototype.union=function(){var t=on.call(arguments,0);return t=t.filter(function(t){return 0!==t.size}),0===t.length?this:0===this.size&&1===t.length?this.constructor(t[0]):this.withMutations(function(e){for(var r=0;t.length>r;r++)l(t[r]).forEach(function(t){return e.add(t)})})},Ar.prototype.intersect=function(){var t=on.call(arguments,0);if(0===t.length)return this;t=t.map(function(t){return l(t)});var e=this;return this.withMutations(function(r){e.forEach(function(e){t.every(function(t){return t.contains(e)})||r.remove(e)})})},Ar.prototype.subtract=function(){var t=on.call(arguments,0);if(0===t.length)return this;t=t.map(function(t){return l(t)});var e=this;return this.withMutations(function(r){e.forEach(function(e){t.some(function(t){return t.contains(e)})&&r.remove(e)})})},Ar.prototype.merge=function(){return this.union.apply(this,arguments)},Ar.prototype.mergeWith=function(){var t=on.call(arguments,1);return this.union.apply(this,t)},Ar.prototype.sort=function(t){return Lr(qe(this,t))},Ar.prototype.sortBy=function(t,e){return Lr(qe(this,e,t))},Ar.prototype.wasAltered=function(){return this._map.wasAltered()},Ar.prototype.__iterate=function(t,e){var r=this;return this._map.__iterate(function(e,n){return t(n,n,r)},e)},Ar.prototype.__iterator=function(t,e){return this._map.map(function(t,e){return e}).__iterator(t,e)},Ar.prototype.__ensureOwner=function(t){if(t===this.__ownerID)return this;var e=this._map.__ensureOwner(t);return t?this.__make(e,t):(this.__ownerID=t,this._map=e,this)},Ar.isSet=jr;var Qn=\"@@__IMMUTABLE_SET__@@\",Xn=Ar.prototype;Xn[Qn]=!0,Xn[un]=Xn.remove,Xn.mergeDeep=Xn.merge,Xn.mergeDeepWith=Xn.mergeWith,Xn.withMutations=Un.withMutations,Xn.asMutable=Un.asMutable,Xn.asImmutable=Un.asImmutable,Xn.__empty=Kr,Xn.__make=Ur;var Fn;t(Lr,Ar),Lr.of=function(){return this(arguments)},Lr.fromKeys=function(t){return this(p(t).keySeq())},Lr.prototype.toString=function(){return this.__toString(\"OrderedSet {\",\"}\")\n},Lr.isOrderedSet=Tr;var Gn=Lr.prototype;Gn[yn]=!0,Gn.__empty=Br,Gn.__make=Wr;var Zn;t(Cr,V),Cr.prototype.toString=function(){return this.__toString(Pr(this)+\" {\",\"}\")},Cr.prototype.has=function(t){return this._defaultValues.hasOwnProperty(t)},Cr.prototype.get=function(t,e){if(!this.has(t))return e;var r=this._defaultValues[t];return this._map?this._map.get(t,r):r},Cr.prototype.clear=function(){if(this.__ownerID)return this._map&&this._map.clear(),this;var t=Object.getPrototypeOf(this).constructor;return t._empty||(t._empty=Jr(this,Qe()))},Cr.prototype.set=function(t,e){if(!this.has(t))throw Error('Cannot set unknown key \"'+t+'\" on '+Pr(this));var r=this._map&&this._map.set(t,e);return this.__ownerID||r===this._map?this:Jr(this,r)},Cr.prototype.remove=function(t){if(!this.has(t))return this;var e=this._map&&this._map.remove(t);return this.__ownerID||e===this._map?this:Jr(this,e)},Cr.prototype.wasAltered=function(){return this._map.wasAltered()},Cr.prototype.__iterator=function(t,e){var r=this;return p(this._defaultValues).map(function(t,e){return r.get(e)}).__iterator(t,e)},Cr.prototype.__iterate=function(t,e){var r=this;return p(this._defaultValues).map(function(t,e){return r.get(e)}).__iterate(t,e)},Cr.prototype.__ensureOwner=function(t){if(t===this.__ownerID)return this;var e=this._map&&this._map.__ensureOwner(t);return t?Jr(this,e,t):(this.__ownerID=t,this._map=e,this)};var $n=Cr.prototype;$n[un]=$n.remove,$n.deleteIn=$n.removeIn=Un.removeIn,$n.merge=Un.merge,$n.mergeWith=Un.mergeWith,$n.mergeIn=Un.mergeIn,$n.mergeDeep=Un.mergeDeep,$n.mergeDeepWith=Un.mergeDeepWith,$n.mergeDeepIn=Un.mergeDeepIn,$n.setIn=Un.setIn,$n.update=Un.update,$n.updateIn=Un.updateIn,$n.withMutations=Un.withMutations,$n.asMutable=Un.asMutable,$n.asImmutable=Un.asImmutable,t(Nr,k),Nr.prototype.toString=function(){return 0===this.size?\"Range []\":\"Range [ \"+this._start+\"...\"+this._end+(this._step>1?\" by \"+this._step:\"\")+\" ]\"},Nr.prototype.get=function(t,e){return this.has(t)?this._start+u(this,t)*this._step:e},Nr.prototype.contains=function(t){var e=(t-this._start)/this._step;\nreturn e>=0&&this.size>e&&e===Math.floor(e)},Nr.prototype.slice=function(t,e){return a(t,e,this.size)?this:(t=h(t,this.size),e=f(e,this.size),t>=e?new Nr(0,0):new Nr(this.get(t,this._end),this.get(e,this._end),this._step))},Nr.prototype.indexOf=function(t){var e=t-this._start;if(e%this._step===0){var r=e/this._step;if(r>=0&&this.size>r)return r}return-1},Nr.prototype.lastIndexOf=function(t){return this.indexOf(t)},Nr.prototype.__iterate=function(t,e){for(var r=this.size-1,n=this._step,i=e?this._start+r*n:this._start,o=0;r>=o;o++){if(t(i,o,this)===!1)return o+1;i+=e?-n:n}return o},Nr.prototype.__iterator=function(t,e){var r=this.size-1,n=this._step,i=e?this._start+r*n:this._start,o=0;return new S(function(){var u=i;return i+=e?-n:n,o>r?I():z(t,o++,u)})},Nr.prototype.equals=function(t){return t instanceof Nr?this._start===t._start&&this._end===t._end&&this._step===t._step:Hr(this,t)};var ti;t(Vr,k),Vr.prototype.toString=function(){return 0===this.size?\"Repeat []\":\"Repeat [ \"+this._value+\" \"+this.size+\" times ]\"},Vr.prototype.get=function(t,e){return this.has(t)?this._value:e},Vr.prototype.contains=function(t){return X(this._value,t)},Vr.prototype.slice=function(t,e){var r=this.size;return a(t,e,r)?this:new Vr(this._value,f(e,r)-h(t,r))},Vr.prototype.reverse=function(){return this},Vr.prototype.indexOf=function(t){return X(this._value,t)?0:-1},Vr.prototype.lastIndexOf=function(t){return X(this._value,t)?this.size:-1},Vr.prototype.__iterate=function(t){for(var e=0;this.size>e;e++)if(t(this._value,e,this)===!1)return e+1;return e},Vr.prototype.__iterator=function(t){var e=this,r=0;return new S(function(){return e.size>r?z(t,r++,e._value):I()})},Vr.prototype.equals=function(t){return t instanceof Vr?X(this._value,t._value):Hr(t)};var ei;_.Iterator=S,Yr(_,{toArray:function(){se(this.size);var t=Array(this.size||0);return this.valueSeq().__iterate(function(e,r){t[r]=e}),t},toIndexedSeq:function(){return new he(this)},toJS:function(){return this.toSeq().map(function(t){return t&&\"function\"==typeof t.toJS?t.toJS():t}).__toJS()\n},toJSON:function(){return this.toSeq().map(function(t){return t&&\"function\"==typeof t.toJSON?t.toJSON():t}).__toJS()},toKeyedSeq:function(){return new ae(this,!0)},toMap:function(){return Le(this.toKeyedSeq())},toObject:function(){se(this.size);var t={};return this.__iterate(function(e,r){t[r]=e}),t},toOrderedMap:function(){return Ir(this.toKeyedSeq())},toOrderedSet:function(){return Lr(d(this)?this.valueSeq():this)},toSet:function(){return Ar(d(this)?this.valueSeq():this)},toSetSeq:function(){return new fe(this)},toSeq:function(){return m(this)?this.toIndexedSeq():d(this)?this.toKeyedSeq():this.toSetSeq()},toStack:function(){return Er(d(this)?this.valueSeq():this)},toList:function(){return fr(d(this)?this.valueSeq():this)},toString:function(){return\"[Iterable]\"},__toString:function(t,e){return 0===this.size?t+e:t+\" \"+this.toSeq().map(this.__toStringMapper).join(\", \")+\" \"+e},concat:function(){var t=on.call(arguments,0);return Oe(this,Se(this,t))},contains:function(t){return this.some(function(e){return X(e,t)})},entries:function(){return this.__iterator(gn)},every:function(t,e){se(this.size);var r=!0;return this.__iterate(function(n,i,o){return t.call(e,n,i,o)?void 0:(r=!1,!1)}),r},filter:function(t,e){return Oe(this,le(this,t,e,!0))},find:function(t,e,r){var n=this.findEntry(t,e);return n?n[1]:r},findEntry:function(t,e){var r;return this.__iterate(function(n,i,o){return t.call(e,n,i,o)?(r=[i,n],!1):void 0}),r},findLastEntry:function(t,e){return this.toSeq().reverse().findEntry(t,e)},forEach:function(t,e){return se(this.size),this.__iterate(e?t.bind(e):t)},join:function(t){se(this.size),t=void 0!==t?\"\"+t:\",\";var e=\"\",r=!0;return this.__iterate(function(n){r?r=!1:e+=t,e+=null!==n&&void 0!==n?\"\"+n:\"\"}),e},keys:function(){return this.__iterator(dn)},map:function(t,e){return Oe(this,pe(this,t,e))},reduce:function(t,e,r){se(this.size);var n,i;return arguments.length<2?i=!0:n=e,this.__iterate(function(e,o,u){i?(i=!1,n=e):n=t.call(r,n,e,o,u)}),n},reduceRight:function(){var t=this.toKeyedSeq().reverse();return t.reduce.apply(t,arguments)\n},reverse:function(){return Oe(this,ve(this,!0))},slice:function(t,e){return Oe(this,me(this,t,e,!0))},some:function(t,e){return!this.every(Fr(t),e)},sort:function(t){return Oe(this,qe(this,t))},values:function(){return this.__iterator(mn)},butLast:function(){return this.slice(0,-1)},isEmpty:function(){return void 0!==this.size?0===this.size:!this.some(function(){return!0})},count:function(t,e){return o(t?this.toSeq().filter(t,e):this)},countBy:function(t,e){return ye(this,t,e)},equals:function(t){return Hr(this,t)},entrySeq:function(){var t=this;if(t._cache)return new j(t._cache);var e=t.toSeq().map(Xr).toIndexedSeq();return e.fromEntrySeq=function(){return t.toSeq()},e},filterNot:function(t,e){return this.filter(Fr(t),e)},findLast:function(t,e,r){return this.toKeyedSeq().reverse().find(t,e,r)},first:function(){return this.find(s)},flatMap:function(t,e){return Oe(this,Ie(this,t,e))},flatten:function(t){return Oe(this,ze(this,t,!0))},fromEntrySeq:function(){return new ce(this)},get:function(t,e){return this.find(function(e,r){return X(r,t)},void 0,e)},getIn:function(t,e){for(var r,n=this,i=Ke(t);!(r=i.next()).done;){var o=r.value;if(n=n&&n.get?n.get(o,fn):fn,n===fn)return e}return n},groupBy:function(t,e){return de(this,t,e)},has:function(t){return this.get(t,fn)!==fn},hasIn:function(t){return this.getIn(t,fn)!==fn},isSubset:function(t){return t=\"function\"==typeof t.contains?t:_(t),this.every(function(e){return t.contains(e)})},isSuperset:function(t){return t.isSubset(this)},keySeq:function(){return this.toSeq().map(Qr).toIndexedSeq()},last:function(){return this.toSeq().reverse().first()},max:function(t){return De(this,t)},maxBy:function(t,e){return De(this,e,t)},min:function(t){return De(this,t?Gr(t):tn)},minBy:function(t,e){return De(this,e?Gr(e):tn,t)},rest:function(){return this.slice(1)},skip:function(t){return this.slice(Math.max(0,t))},skipLast:function(t){return Oe(this,this.toSeq().reverse().skip(t).reverse())},skipWhile:function(t,e){return Oe(this,we(this,t,e,!0))},skipUntil:function(t,e){return this.skipWhile(Fr(t),e)\n},sortBy:function(t,e){return Oe(this,qe(this,e,t))},take:function(t){return this.slice(0,Math.max(0,t))},takeLast:function(t){return Oe(this,this.toSeq().reverse().take(t).reverse())},takeWhile:function(t,e){return Oe(this,ge(this,t,e))},takeUntil:function(t,e){return this.takeWhile(Fr(t),e)},valueSeq:function(){return this.toIndexedSeq()},hashCode:function(){return this.__hash||(this.__hash=en(this))}});var ri=_.prototype;ri[pn]=!0,ri[zn]=ri.values,ri.__toJS=ri.toArray,ri.__toStringMapper=Zr,ri.inspect=ri.toSource=function(){return\"\"+this},ri.chain=ri.flatMap,function(){try{Object.defineProperty(ri,\"length\",{get:function(){if(!_.noLengthWarning){var t;try{throw Error()}catch(e){t=e.stack}if(-1===t.indexOf(\"_wrapObject\"))return console&&console.warn&&console.warn(\"iterable.length has been deprecated, use iterable.size or iterable.count(). This warning will become a silent error in a future version. \"+t),this.size}}})}catch(t){}}(),Yr(p,{flip:function(){return Oe(this,_e(this))},findKey:function(t,e){var r=this.findEntry(t,e);return r&&r[0]},findLastKey:function(t,e){return this.toSeq().reverse().findKey(t,e)},keyOf:function(t){return this.findKey(function(e){return X(e,t)})},lastKeyOf:function(t){return this.findLastKey(function(e){return X(e,t)})},mapEntries:function(t,e){var r=this,n=0;return Oe(this,this.toSeq().map(function(i,o){return t.call(e,[o,i],n++,r)}).fromEntrySeq())},mapKeys:function(t,e){var r=this;return Oe(this,this.toSeq().flip().map(function(n,i){return t.call(e,n,i,r)}).flip())}});var ni=p.prototype;ni[vn]=!0,ni[zn]=ri.entries,ni.__toJS=ri.toObject,ni.__toStringMapper=function(t,e){return e+\": \"+Zr(t)},Yr(v,{toKeyedSeq:function(){return new ae(this,!1)},filter:function(t,e){return Oe(this,le(this,t,e,!1))},findIndex:function(t,e){var r=this.findEntry(t,e);return r?r[0]:-1},indexOf:function(t){var e=this.toKeyedSeq().keyOf(t);return void 0===e?-1:e},lastIndexOf:function(t){return this.toSeq().reverse().indexOf(t)},reverse:function(){return Oe(this,ve(this,!1))},slice:function(t,e){return Oe(this,me(this,t,e,!1))\n},splice:function(t,e){var r=arguments.length;if(e=Math.max(0|e,0),0===r||2===r&&!e)return this;t=h(t,this.size);var n=this.slice(0,t);return Oe(this,1===r?n:n.concat(i(arguments,2),this.slice(t+e)))},findLastIndex:function(t,e){var r=this.toKeyedSeq().findLastKey(t,e);return void 0===r?-1:r},first:function(){return this.get(0)},flatten:function(t){return Oe(this,ze(this,t,!1))},get:function(t,e){return t=u(this,t),0>t||1/0===this.size||void 0!==this.size&&t>this.size?e:this.find(function(e,r){return r===t},void 0,e)},has:function(t){return t=u(this,t),t>=0&&(void 0!==this.size?1/0===this.size||this.size>t:-1!==this.indexOf(t))},interpose:function(t){return Oe(this,be(this,t))},interleave:function(){var t=[this].concat(i(arguments)),e=Ee(this.toSeq(),k.of,t),r=e.flatten(!0);return e.size&&(r.size=e.size*t.length),Oe(this,r)},last:function(){return this.get(-1)},skipWhile:function(t,e){return Oe(this,we(this,t,e,!1))},zip:function(){var t=[this].concat(i(arguments));return Oe(this,Ee(this,$r,t))},zipWith:function(t){var e=i(arguments);return e[0]=this,Oe(this,Ee(this,t,e))}}),v.prototype[ln]=!0,v.prototype[yn]=!0,Yr(l,{get:function(t,e){return this.has(t)?t:e},contains:function(t){return this.has(t)},keySeq:function(){return this.valueSeq()}}),l.prototype.has=ri.contains,Yr(x,p.prototype),Yr(k,v.prototype),Yr(A,l.prototype),Yr(V,p.prototype),Yr(Y,v.prototype),Yr(Q,l.prototype);var ii={Iterable:_,Seq:O,Collection:N,Map:Le,OrderedMap:Ir,List:fr,Stack:Er,Set:Ar,OrderedSet:Lr,Record:Cr,Range:Nr,Repeat:Vr,is:X,fromJS:F};return ii});";

eval(immutable);

reservedInJs = newSetWith.apply(null, ("abstract arguments boolean break byte case catch char class " + "const continue debugger default delete do double else enum eval export " + "extends final finally float for function goto if implements import in " + "instanceof int interface let long native new null package private protected " + "public return short static super switch synchronized this throw throws transient " + "try typeof var void volatile while with yield").split(' '));

compiledModules = newMap();

moduleGraph = newMap();

compileTopLevel = function(source, moduleName) {
  var ast, ctx, directRequires, js, required, toInject, _ref1;
  if (moduleName == null) {
    moduleName = '@unnamed';
  }
  required = newSetWith('Prelude');
  if ((!lookupInMap(compiledModules, 'Prelude')) && moduleName !== 'Prelude') {
    return {
      request: 'Prelude'
    };
  } else {
    directRequires = subtractSets(required, newSetWith(moduleName));
    replaceOrAddToMap(moduleGraph, moduleName, {
      requires: directRequires
    });
    toInject = collectRequiresFor(moduleName);
    ctx = injectedContext(toInject);
    _ref1 = compileCtxAstToJs(topLevel, ctx, astFromSource("(" + source + ")", -1, -1)), js = _ref1.js, ast = _ref1.ast;
    checkTypes(ctx);
    replaceOrAddToMap(compiledModules, moduleName, {
      declared: subtractContexts(ctx, injectedContext(toInject)),
      js: js
    });
    attachPrintedTypes(ctx, ast);
    return {
      js: js,
      ast: ast,
      types: typeEnumaration(ctx)
    };
  }
};

compileExpression = function(source, moduleName) {
  var ast, ctx, expression, js, module, toInject;
  if (moduleName == null) {
    moduleName = '@unnamed';
  }
  module = lookupInMap(compiledModules, moduleName);
  toInject = concatSets(collectRequiresFor(moduleName), newSetWith(moduleName));
  ctx = injectedContext(toInject);
  ast = astFromSource("(" + source + ")", -1, -1);
  expression = _terms(ast)[0];
  js = compileCtxAstToJs(topLevelExpression, ctx, expression).js;
  checkTypes(ctx);
  attachPrintedTypes(ctx, expression);
  return {
    js: library + immutable + (listOfLines(map(lookupJs, setToArray(toInject)))) + js,
    ast: ast
  };
};

checkTypes = function(ctx) {
  var failed;
  if (_notEmpty((failed = ctx.substitution.fails))) {
    throw new Error(failed[0]);
  }
};

lookupJs = function(moduleName) {
  var js, _ref1;
  js = (_ref1 = lookupInMap(compiledModules, moduleName)) != null ? _ref1.js : void 0;
  if (!js) {
    return console.error("" + moduleName + " not found");
  } else {
    return js;
  }
};

subtractContexts = function(ctx, what) {
  var classes, definitions, typeNames;
  definitions = subtractMaps(ctx._scope(), what._scope());
  typeNames = subtractMaps(ctx._scope().typeNames, what._scope().typeNames);
  classes = subtractMaps(ctx._scope().classes, what._scope().classes);
  macros = subtractMaps(objectToMap(ctx._macros), objectToMap(what._macros));
  return {
    definitions: definitions,
    typeNames: typeNames,
    classes: classes,
    macros: macros
  };
};

injectedContext = function(modulesToInject) {
  var ctx, name;
  ctx = new Context;
  for (name in values(modulesToInject)) {
    injectContext(ctx, (lookupInMap(compiledModules, name)).declared);
  }
  return ctx;
};

injectContext = function(ctx, compiledModule) {
  var classes, definition, definitions, macro, name, topScope, typeNames, _ref1, _ref2;
  definitions = compiledModule.definitions, typeNames = compiledModule.typeNames, classes = compiledModule.classes, macros = compiledModule.macros;
  _ref1 = values(macros);
  for (name in _ref1) {
    macro = _ref1[name];
    if (ctx._macros[name]) {
      throw new Error("Macro " + name + " already defined");
    } else {
      ctx._macros[name] = macro;
    }
  }
  topScope = ctx._scope();
  _ref2 = values(definitions);
  for (name in _ref2) {
    definition = _ref2[name];
    replaceOrAddToMap(topScope, name, definition);
  }
  topScope.typeNames = concatMaps(topScope.typeNames, typeNames);
  topScope.classes = concatMaps(topScope.classes, classes);
  return ctx;
};

collectRequiresFor = function(name) {
  return collectRequiresWithAcc(name, newSet());
};

collectRequiresWithAcc = function(name, acc) {
  var collected, compiled, requires;
  compiled = lookupInMap(moduleGraph, name);
  if (!compiled) {
    console.error("" + name + " module not found");
    return newSet();
  } else {
    requires = compiled.requires;
    collected = reduceSet(collectRequiresWithAcc, concatSets(requires, acc), subtractSets(requires, acc));
    return concatSets(collected, acc);
  }
};

syntaxedExpHtml = function(string) {
  return collapse(toHtml(astize(tokenize(string))));
};

syntaxedType = function(type) {
  return collapse(toHtml(typeCompile(new Context, type)));
};

compileTopLevelSource = function(source) {
  var ast, ctx, js, _ref1;
  _ref1 = compileToJs(topLevel, "(" + source + ")", -1, -1), js = _ref1.js, ast = _ref1.ast, ctx = _ref1.ctx;
  attachPrintedTypes(ctx, ast);
  return {
    js: js,
    ast: ast,
    types: typeEnumaration(ctx)
  };
};

compileTopLevelAndExpression = function(source) {
  return topLevelAndExpression(source);
};

topLevelAndExpression = function(source) {
  var ast, compiledDefinitions, compiledExpression, ctx, expression, terms, _j, _ref1;
  ast = astize(tokenize("(" + source + ")", -1), -1);
  _ref1 = _terms(ast), terms = 2 <= _ref1.length ? __slice.call(_ref1, 0, _j = _ref1.length - 1) : (_j = 0, []), expression = _ref1[_j++];
  ctx = (compiledDefinitions = compileAstToJs(definitionList, pairs(terms))).ctx;
  compiledExpression = compileCtxAstToJs(topLevelExpression, ctx, expression);
  attachPrintedTypes(ctx, expression);
  return {
    types: ctx._scope(),
    subs: ctx.substitution.fails,
    ast: ast,
    compiled: library + immutable + compiledDefinitions.js + compiledExpression.js
  };
};

typeEnumaration = function(ctx) {
  return values(mapMap(_type, ctx._scope()));
};

compileToJs = function(compileFn, source, posOffset, depthOffset) {
  if (posOffset == null) {
    posOffset = 0;
  }
  if (depthOffset == null) {
    depthOffset = 0;
  }
  return compileAstToJs(compileFn, astFromSource(source, posOffset, depthOffset));
};

astFromSource = function(source, posOffset, depthOffset) {
  if (posOffset == null) {
    posOffset = 0;
  }
  if (depthOffset == null) {
    depthOffset = 0;
  }
  return astize(tokenize(source, posOffset), depthOffset);
};

compileAstToJs = function(compileFn, ast) {
  var ctx;
  ctx = new Context;
  return compileCtxAstToJs(compileFn, ctx, ast);
};

compileCtxAstToJs = function(compileFn, ctx, ast) {
  var ir, js, jsIr;
  ir = compileFn(ctx, ast);
  jsIr = translateIr(ctx, ir);
  js = (Array.isArray(jsIr) ? translateStatementsToJs : translateToJs)(jsIr);
  return {
    ctx: ctx,
    ast: ast,
    js: js
  };
};

astizeList = function(source) {
  return parentize(astize(tokenize("(" + source + ")", -1), -1));
};

astizeExpression = function(source) {
  return parentize(astize(tokenize(source)));
};

astizeExpressionWithWrapper = function(source) {
  return parentize(astize(tokenize("(" + source + ")", -1), -1));
};

attachPrintedTypes = function(ctx, ast) {
  return visitExpressions(ast, function(expression) {
    if (expression.tea) {
      return expression.tea = highlightType(substitute(ctx.substitution, expression.tea));
    }
  });
};

_operator = function(call) {
  return (_terms(call))[0];
};

_arguments = function(call) {
  return (_terms(call)).slice(1);
};

_terms = function(form) {
  return noWhitespace(form.slice(1, -1));
};

_snd = function(_arg) {
  var a, b;
  a = _arg[0], b = _arg[1];
  return b;
};

_fst = function(_arg) {
  var a, b;
  a = _arg[0], b = _arg[1];
  return a;
};

_labelName = function(atom) {
  return (_symbol(atom)).slice(0, -1);
};

_stringValue = function(_arg) {
  var symbol;
  symbol = _arg.symbol;
  return symbol.slice(1, -1);
};

_symbol = function(_arg) {
  var symbol;
  symbol = _arg.symbol;
  return symbol;
};

join = function(seq1, seq2) {
  return seq1.concat(seq2);
};

concatMap = function(fn, list) {
  return concat(map(fn, list));
};

concat = function(lists) {
  var _ref1;
  return (_ref1 = []).concat.apply(_ref1, lists);
};

reverse = function(list) {
  return (map(id, list)).reverse();
};

id = function(x) {
  return x;
};

map = function(fn, list) {
  if (list) {
    return list.map(fn);
  } else {
    return function(list) {
      return map(fn, list);
    };
  }
};

allMap = function(fn, list) {
  return all(map(fn, list));
};

all = function(list) {
  return (filter(_is, list)).length === list.length;
};

any = function(list) {
  return (filter(_is, list)).length > 0;
};

filter = function(fn, list) {
  return list.filter(fn);
};

partition = function(fn, list) {
  return [
    filter(fn, list), filter((function(x) {
      return !(fn(x));
    }), list)
  ];
};

_notEmpty = function(x) {
  return x.length > 0;
};

_is = function(x) {
  return !!x;
};

__ = function(fna, fnb) {
  return function(x) {
    return fna(fnb(x));
  };
};

test = function(testName, teaSource, result) {
  var compiled, e, got;
  try {
    compiled = topLevelAndExpression(teaSource);
  } catch (_error) {
    e = _error;
    console.log(_error);
    logError("Failed to compile test |" + testName + "|\n" + teaSource + "\n", e);
    return;
  }
  try {
    log(collapse(toHtml(compiled.ast)));
    if (_notEmpty(compiled.subs)) {
      log(compiled.subs);
    }
    if (result !== (got = eval(compiled.compiled))) {
      return log("'" + testName + "' expected", result, "got", got);
    }
  } catch (_error) {
    e = _error;
    return logError("Error in test |" + testName + "|\n" + teaSource + "\n", e);
  }
};

tests = ['simple defs', "a 2", "a", 2, 'more defs', "a 2\nb 3", "a", 2, 'constant data', "Color (data Red Blue)\nr Red\nb Blue\nr2 Red", "(== r r2)", true, 'match numbers', "positive (fn [n]\n(match n\n  0 False\n  m True))", "(positive 3)", true, 'composite data', "Person (data\n  Baby\n  Adult [name: String])\n\na (Adult \"Adam\")\n\nb Baby\n\nname (fn [person]\n  (match person\n    (Adult name) name))", "(name a)", "Adam", 'records', "Person (record name: String id: Num)\n\nname (fn [person]\n  (match person\n    (Person name id) name))", "(name ((Person id: 3) \"Mike\"))", "Mike", 'late bound function', "f (fn [x] (g x))\ng (fn [x] 2)", "(f 4)", 2, 'late bound def', "[x y] z\nz [1 2]", "y", 2, 'tuples', "snd (fn [pair]\n(match pair\n  [x y] y))", "(snd [1 2])", 2, 'match data', "Person (record name: String id: Num)\nname (fn [person]\n  (match person\n    (Person \"Joe\" id) 0\n    (Person name id) id))", "(name (Person \"Mike\" 3))", 3, 'seqs', "{x y z} list\nlist {1 2 3}", "z", 3, 'match seq', "tail? (fn [list]\n  (match list\n    {} False\n    xx True))\n{x ..xs} {1}", "(tail? xs)", false, 'seq splice in match', "& (macro [what to]\n  (: (Fn a (List a) (List a)))\n  (Js.call (Js.access to \"unshift\") {what}))\n\nmap (fn [what to]\n  (match to\n    {} {}\n    {x ..xs} (& (what x) (map what xs))))\n\n{{x} ..xs} (map (& 42) {{}})", "x", 42, 'typed function', "f (fn [x y]\n(: (Fn Bool String Bool))\nx)", "(f True \"a\")", true, 'classes', "Show (class [a]\n  show (fn [x] (: (Fn a String))))\n\nshow-string (instance (Show String)\n  show (fn [x] x))\n\naliased-show (fn [something]\n  (show something))\n\nshowed-simply (show \"Hello\")\nshowed-via-alias (aliased-show \"Hello\")", "(== showed-simply showed-via-alias)", true, 'multiple methods', "Util (class [a]\n  show (fn [x] (: (Fn a String)))\n  read (fn [x] (: (Fn String a))))\n\nutil-string (instance (Util String)\n   show (fn [x] x)\n   read (fn [x] x))\n\ntest (fn [string]\n  (: (Fn String String))\n  (read (show string)))", "(test \"Hello\")", "Hello", 'multiple instances', "Show (class [a]\n  show (fn [x] (: (Fn a String))))\n\nshow-string (instance (Show String)\n  show (fn [x] x))\n\nshow-bool (instance (Show Bool)\n  show (fn [x]\n    (match x\n      True \"True\"\n      False \"False\")))", "(show False)", "False", 'instance constraints', "Show (class [a]\n  show (fn [x] (: (Fn a String))))\n\nshow-string (instance (Show String)\n  show (fn [x] x))\n\nshow-snd (instance (Show [a b])\n  {(Show a) (Show b)}\n  show (fn [x]\n    (match x\n      [fst snd] (show snd))))", "(show [\"Adam\" \"Michal\"])", "Michal", 'multiple constraints', "Show (class [a]\n  show (fn [x] (: (Fn a String))))\n\nHide (class [a]\n  hide (fn [x] (: (Fn a String))))\n\nshow-string (instance (Show String)\n  show (fn [x] x))\n\nhide-string (instance (Hide String)\n  hide (fn [x] x))\n\nf (fn [x]\n  (== (show x) (hide x)))", "(f \"Hello\")", true, 'superclasses', "Eq (class [a]\n  = (fn [x y] (: (Fn a a Bool))))\n\nOrd (class [a]\n  {(Eq a)}\n  <= (fn [x y] (: (Fn a a Bool))))\n\neq-bool (instance (Eq Bool)\n  = (fn [x y]\n    (match [x y]\n      [True True] True\n      [False False] True\n      [w z] False)))\n\nord-bool (instance (Ord Bool)\n  <= (fn [x y]\n    (match [x y]\n      [True any] True\n      [w z] (= w z))))\n\ntest (fn [x]\n  (== (<= x x) (= x x)))", "(test False)", true, 'function with constrained result', "Eq (class [a]\n  = (fn [x y] (: (Fn a a Bool))))\n\n!= (fn [x y]\n  (not (= x y)))\n\nnot (fn [x]\n  (match x\n    False True\n    True False))\n\neq-bool (instance (Eq Bool)\n  = (fn [x y]\n    (match [x y]\n      [True True] True\n      [False False] True\n      [w z] False)))", "(!= False True)", true, 'polymorphic data', "Maybe (data [a]\n  None\n  Just [value: a])\n\nfrom-just (fn [maybe]\n  (match maybe\n    (Just x) x))", "(from-just (Just 42))", 42, 'js unary op', "~ (macro [x]\n  (: (Fn Num Num))\n  (Js.unary \"-\" x))\nx ~42", "(~ x)", 42, 'js binary op', "+ (macro [x y]\n  (: (Fn Num Num Num))\n  (Js.binary \"+\" x y))", "(+ 1 2)", 3, 'js cond', "if (macro [what then else]\n  (: (Fn Bool a a a))\n  (Js.ternary what then else))", "(if False 1 2)", 2, 'currying functional macros', "* (macro [x y]\n  (: (Fn Num Num Num))\n  (Js.binary \"*\" x y))\n\nf (* 2)", "(f 3)", 6, 'getters', "Person (record\n  first: String last: String)\n\njack (Person \"Jack\" \"Jack\")", "(== (Person.first jack) (Person.last jack))", true, 'macros in instances', "Show (class [a]\n  show (fn [x] (: (Fn a String))))\n\nnum-to-string (macro [n]\n  (: (Fn Num String))\n  (Js.binary \"+\" n \"\\\"\\\"\"))\n\nshow-num (instance (Show Num)\n  show (fn [x]\n    (num-to-string x)))", "(show 3)", '3', 'fib', "fibonacci (fn [month] (adults month))\n\nadults (fn [month]\n  (match month\n    1 0\n    n (+ (adults previous-month) (babies previous-month)))\n  previous-month (- 1 month))\n\nbabies (fn [month]\n  (match month\n    1 1\n    n (adults (- 1 month))))\n\n+ (macro [x y]\n  (: (Fn Num Num Num))\n  (Js.binary \"+\" x y))\n\n- (macro [x y]\n  (: (Fn Num Num Num))\n  (Js.binary \"-\" y x))", "(fibonacci 7)", 8, 'Map literal', "data {a: True b: False}\n\nkey? (macro [what in]\n  (: (Fn k (Map k i) Bool))\n  (Js.call (Js.access in \"has\") {what}))\n\nat (macro [key in]\n  (: (Fn k (Map k i) i))\n  (Js.call (Js.access in \"get\") {key}))", "(== (key? \"c\" data) (at \"b\" data))", true, 'create Set', "data (Set \"Adam\" \"Vojta\" \"Michal\")\n\nelem? (macro [what in]\n  (: (Fn i (Set i) Bool))\n  (Js.call (Js.access in \"has\") {what}))", "(elem? \"Michal\" data)", true, 'create Map', "data (Map 3 \"a\" 5 \"b\")\n\nat (macro [key in]\n  (: (Fn k (Map k i) i))\n  (Js.call (Js.access in \"get\") {key}))", "(at 5 data)", 'b', 'type alias', "Point (type [Num Num])\n\nx (fn [p]\n  (: (Fn Point Num))\n  first\n  [first second] p)", "(x [3 4])", 3, 'collections', "Collection (class [collection]\n  elem? (fn [what in]\n    (: (Fn item (collection item) Bool))\n    (# Whether in contains what .)))\n\nBag (class [bag]\n  {(Collection bag)}\n\n  fold (fn [with initial over]\n    (: (Fn (Fn item b b) b (bag item)))\n    (# Fold over with using initial .))\n\n  length (fn [bag]\n    (: (Fn (bag item) Num))\n    (# The number of items in the bag .))\n\n  empty? (fn [bag]\n    (: (Fn (bag item) Bool))\n    (# Whether the bag contains no elements.)))\n\nlist-elem? (macro [what in]\n  (: (Fn item (List item) Bool))\n  (Js.call (Js.access in \"contains\") {what}))\n\ncollection-list (instance (Collection List)\n  elem? (fn [what in]\n    (list-elem? what in)))", "(elem? 3 {1 2 3})", true, 'multiparam classes', "Collection (class [ce e]\n  first (fn [in]\n    (: (Fn (ce e) e))))\n\nlist-first (macro [in]\n  (: (Fn (List item) item))\n  (Js.call (Js.access in \"first\") {}))\n\nlist-collection (instance (Collection List a)\n  first (fn [in]\n    (list-first in)))", "(first {42 43 44})", 42, 'functional deps', "Collection (class [ce e]\n  (# (| ce: e))\n  first (fn [in]\n    (: (Fn ce e))))\n\nlist-first (macro [in]\n  (: (Fn (List item) item))\n  (Js.call (Js.access in \"first\") {}))\n\nlist-collection (instance (Collection (List a) a)\n  first (fn [in]\n    (list-first in)))", "(first {42 43 44})", 42];

testNamed = function(givenName) {
  var expression, name, result, source, _j, _len1, _ref1, _ref2;
  _ref1 = tuplize(4, tests);
  for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
    _ref2 = _ref1[_j], name = _ref2[0], source = _ref2[1], expression = _ref2[2], result = _ref2[3];
    if (name === givenName) {
      return source;
    }
  }
  throw new Error("Test " + givenName + " not found!");
};

logError = function(message, error) {
  return log(message, error.message, error.stack.replace(/\n?((\w+)[^>\n]+>[^>\n]+>[^>\n]+:(\d+:\d+)|.*)(?=\n)/g, '\n$2 $3').replace(/\n (?=\n)/g, ''));
};

debug = function(fun) {
  var e;
  try {
    return fun();
  } catch (_error) {
    e = _error;
    return logError("debug", e);
  }
};

runTests = function(tests) {
  var expression, name, result, source, _j, _len1, _ref1, _ref2;
  _ref1 = tuplize(4, tests);
  for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
    _ref2 = _ref1[_j], name = _ref2[0], source = _ref2[1], expression = _ref2[2], result = _ref2[3];
    test(name, source + "\n" + expression, result);
  }
  return "Finished";
};


var log = console.log.bind(console);

window.tests = [
  'bla bla',
  "+ (macro [x y]\n  (: (Fn Num Num Num))\n  (Js.binary \"+\" x y))\n\n- (macro [what from]\n  (: (Fn Num Num Num))\n  (Js.binary \"-\" from what))\n\n* (macro [x y]\n  (: (Fn Num Num Num))\n  (Js.binary \"*\" x y))\n\n/ (macro [by what]\n  (: (Fn Num Num Num))\n  (Js.binary \"/\" what by))\n\nmod (macro [by of]\n  (: (Fn Num Num Num))\n  (Js.binary \"%\" of by))\n\nsqrt (macro [n]\n  (: (Fn Num Num))\n  (Js.call \"Math.sqrt\" {n}))\n\n^ (macro [to what]\n  (: (Fn Num Num Num))\n  (Js.call \"Math.pow\" {what to}))\n\nsin (macro [x]\n  (: (Fn Num Num))\n  (# x is in radians.)\n  (Js.call \"Math.sin\" {x}))\n\ncos (macro [x]\n  (: (Fn Num Num))\n  (# x is in radians.)\n  (Js.call \"Math.cos\" {x}))\n\nrem (fn [by of]\n  (mod by (+ by (mod by of))))\n\n~ (macro [x]\n  (: (Fn Num Num))\n  (Js.unary \"-\" x))\n\nand (macro [first then]\n  (: (Fn Bool Bool Bool))\n  (Js.binary \"&&\" first then))\n\nor (macro [first then]\n  (: (Fn Bool Bool Bool))\n  (Js.binary \"||\" first then))\n\nnot (macro [x]\n  (: (Fn Bool Bool))\n  (Js.unary \"!\" x))\n\nif (macro [what then else]\n  (: (Fn Bool a a a))\n  (Js.ternary what then else))\n\nEq (class [a]\n  = (fn [x y] (: (Fn a a Bool))))\n\n!= (fn [x y]\n  (not (= x y)))\n\nbool= (macro [x y]\n  (: (Fn Bool Bool Bool))\n  (Js.binary \"===\" x y))\n\nbool-eq (instance (Eq Bool)\n  = (fn [x y] (bool= x y)))\n\nnum= (macro [x y]\n  (: (Fn Num Num Bool))\n  (Js.binary \"===\" x y))\n\nnum-eq (instance (Eq Num)\n  = (fn [x y] (num= x y)))\n\nOrd (class [a]\n  {(Eq a)}\n  <= (fn [than what] (: (Fn a a Bool))))\n\n< (fn [than what]\n  (: (Fn a a Bool) (Ord a))\n  (and (<= than what) (not (= than what))))\n\n> (fn [than what]\n  (: (Fn a a Bool) (Ord a))\n  (not (<= than what)))\n\n>= (fn [than what]\n  (: (Fn a a Bool) (Ord a))\n  (or (= than what) (> than what)))\n\nnum<= (macro [than what]\n  (: (Fn Num Num Bool))\n  (Js.binary \"<=\" what than))\n\nnum-ord (instance (Ord Num)\n  <= (fn [than what]\n    (num<= than what)))\n\neven? (fn [x]\n  (: (Fn Num Bool))\n  (= 0 (rem 2 x)))\n\nodd? (fn [x]\n  (: (Fn Num Bool))\n  (not (even? x)))\n\nid (fn [x] (: (Fn a a)) x)\n\nconst (fn [x y] (: (Fn a b a)) x)\n\n. (fn [second first x]\n  (: (Fn (Fn b c) (Fn a b) a c))\n  (second (first x)))\n\nfst (fn [tuple]\n  (: (Fn [a b] a))\n  x\n  [x y] tuple)\n\nsnd (fn [tuple]\n  (: (Fn [a b] b))\n  y\n  [x y] tuple)\n\ncurry (fn [fun x y]\n  (: (Fn (Fn [a b] c) a b c))\n  (fun [x y]))\n\nuncurry (fn [fun tuple]\n  (: (Fn (Fn a b c) [a b] c))\n  (fun x y)\n  [x y] tuple)\n\n& (macro [what to]\n  (: (Fn a (List a) (List a)))\n  (Js.call (Js.access to \"unshift\") {what}))\n\nmap (fn [what over]\n  (match over\n    {} {}\n    {x ..xs} (& (what x) (map what xs))))\n\njoin (fn [what with]\n  (match what\n    {} with\n    {x ..xs} (& x (join xs with))))\n\nfilter (fn [cond list]\n  (match list\n    {} list\n    {x ..xs} (if (cond x)\n      (& x (filter cond xs))\n      (filter cond xs))))\n\nfold (fn [with initial list]\n  (match list\n    {} initial\n    {x ..xs} (fold with (with initial x) xs)))\n\nconcat (fn [lists]\n  (fold join {} lists))\n\nconcat-map (fn [what over]\n  (concat (map what over)))\n\nhead (fn [list]\n  x\n  {x ..xs} list)\n\ntail (fn [list]\n  xs\n  {x ..xs} list)\n\nlength (macro [list]\n  (: (Fn (List a) Num))\n  (Js.access list \"size\"))\n\nat (fn [index in]\n  (match index\n    0 (head in)\n    n (at (- 1 n) (tail in))))\n\ntake (fn [n from]\n  (if (<= 0 n)\n    {}\n    (match from\n      {} from\n      {x ..xs} (& x (take (- 1 n) xs)))))\n\ndrop (fn [n from]\n  (if (<= 0 n)\n    from\n    (match from\n      {} from\n      {x ..xs} (drop (- 1 n) xs))))\n\nrange (fn [from exclude-to]\n  (if (<= from exclude-to)\n    {}\n    (& from (range (+ 1 from) exclude-to))))\n\nsum (fold + 0)\nall (fold and True)\nany (fold or False)\n\nall-map (fn [fun list]\n  (all ((map fun) list)))\n\nany-map (fn [fun list]\n  (any ((map fun) list)))\n\nnull? (fn [list]\n  (= 0 (length list)))\n\nadd (macro [what to]\n  (: (Fn a (Set a) (Set a)))\n  (Js.call (Js.access to \"add\") {what}))\n\nremove (macro [what from]\n  (: (Fn a (Set a) (Set a)))\n  (Js.call (Js.access from \"remove\") {what}))\n\nelem? (macro [what in]\n  (: (Fn a (Set a) Bool))\n  (Js.call (Js.access in \"has\") {what}))\n\nnot-elem? (fn [what in]\n  (not (elem? what in)))\n\nsize (macro [list]\n  (: (Fn (Set a) Num))\n  (Js.access list \"size\"))\n\nempty? (fn [list]\n  (= 0 (size list)))\n\nput (macro [key value into]\n  (: (Fn k v (Map k v) (Map k v)))\n  (Js.call (Js.access into \"set\") {key value}))\n\nget (macro [key from]\n  (: (Fn k (Map k v) v))\n  (Js.call (Js.access from \"get\") {key}))\n\nkey? (macro [key in]\n  (: (Fn k (Map k v) Bool))\n  (Js.call (Js.access in \"has\") {key}))\n\ncount (macro [map]\n  (: (Fn (Map k v) Num))\n  (Js.access map \"size\"))\n\nkey-set (macro [map]\n  (: (Fn (Map k v) (Set k)))\n  (Js.call (Js.access\n      (Js.call (Js.access map \"keySeq\") {}) \"toSet\") {}))\n\nvalue-list (macro [map]\n  (: (Fn (Map k v) (List v)))\n  (Js.call (Js.access map \"toList\") {}))\n\nchars (macro [string]\n  (: (Fn String (List Char)))\n  (Js.call \"Immutable.List\"\n    {(Js.call (Js.access string \"split\") {\"''\"})}))\n\nmake-pi (macro [x]\n  (: (Fn a Num))\n  (Js.access \"Math\" \"PI\"))\n\nmath-pi (make-pi 0)\n\nradians (fn [degrees]\n  (* math-pi (/ 180 degrees)))\n\nRules (type (Map Char String))\nSystem (record angle: Num base: (List Char) rules: Rules)\n\ntree (System 45\n  {\\M}\n  (Map\n    \\M \"N<-M><+M><NM>\"\n    \\N \"NN\"\n    \\< \"<\"\n    \\> \">\"\n    \\+ \"+\"\n    \\- \"-\"))\n\nl-system (fn [system n]\n  (trace\n    (filter (elem? in: (Set \\L \\R \\F))\n      (expand-one mapper\n        (expand (System.rules system) (System.base system) n)))\n    (System.angle system)\n    [1 1 1]))\n\nlookup-char (fn [char from]\n  (chars (get char from)))\n\nexpand-one (fn [rules base]\n  (concat-map (lookup-char from: rules) base))\n\nexpand (fn [rules base n]\n  (reapply (expand-one rules) base n))\n\nreapply (fn [what input n]\n  (match n\n    0 input\n    else (reapply what (what input) (- 1 n))))\n\nVertex (type [Num Num])\nAngle (type Num)\nTurtleState (type [Vertex Angle])\n\nmove (fn [command state rotation]\n  (match command\n    \\F [[(+ x (cos a)) (+ y (sin a))] angle]\n    \\L [pos (+ rotation angle)]\n    \\R [pos (- rotation angle)])\n  [x y] pos\n  a (radians angle)\n  [pos angle] state)\n\nColor (type [Num Num Num])\nColoredLine (type [Vertex Vertex Color])\n\ntrace (fn [commands rotation color]\n  (snd (fold step [initial {}] commands))\n  step (fn [current command]\n    [next (& [from to color] lines)]\n    [to _] next\n    [from _] state\n    [state lines] current\n    next (move command state rotation))\n  initial [[0 0] 90])\n\nmapper (Map\n  \\M \"F\"\n  \\N \"F\"\n  \\+ \"R\"\n  \\- \"L\"\n  \\< \"<\"\n  \\> \">\")\n\ncss-color (fn [color]\n  (format \"rgb<%i, %i, %i>\" (byte r) (byte g) (byte b))\n  [r g b] color\n  byte (* 255))\n",
  "(l-system tree 0)", 1
];

log("hey");
  </script>
   <button onclick="window.runTests(window.tests)">Click me</button>
</body>
</html>

